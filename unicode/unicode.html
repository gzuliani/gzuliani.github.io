<!DOCTYPE html>
<html lang="it"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Da ASCII a Unicode</title>
<link href="../css/main.css" rel="stylesheet" type="text/css">
<link href="css/unicode.css" rel="stylesheet" type="text/css">
</head>
<body>
<p class="page-path"><a href="https://gzuliani.github.io/index.html#unicode">risorse</a> | unicode</p>
<h1>Da ASCII a Unicode</h1>
<p>Il problema di rappresentare la scrittura nei calcolatori risale alle origini dell‚Äôinformatica. La soluzione pi√π frequentemente adottata √® la definizione di una <em>codifica di carattere</em> che consiste nell‚Äôassociare ad ogni simbolo dell‚Äôalfabeto in uso una particolare sequenza di bit. Questa associazione viene a volte erroneamente indicata col termine di <em>set di caratteri</em>, <em>mappa dei caratteri</em>, o <em>code page</em>.</p>
<p>Un tipico esempio di <em>codifica</em>, risalente al 1963 e ancora in uso in ambiente informatico, √® lo standard <em>ASCII</em> ‚Äì <em>American Standard Code for Information Interchange</em>.</p>
<h2>ASCII</h2>
<h3>Cenni storici</h3>
<p>La codifica ASCII nasce in IBM nel 1961 ad opera di Bob Bemer durante lo sviluppo della telescrivente Teletype Model 33. Non soddisfatto delle codifiche gi√† in uso nell‚Äôazienda per cui lavora (ben nove, stando alle sue parole), ed in particolare della codifica EBCDIC ‚Äì <em>Extended Binary Coded Decimal Interchange Code</em> ‚Äì impiegata con successo nei mainframe e minicomputer prodotti fino a quel momento, presenta all‚Äôallora <em>ANA ‚Äì American Standards Association</em> (ora <em>ANSI ‚Äì American National Standards Institute</em>) una proposta per una nuova codifica dalle caratteristiche secondo lui pi√π desiderabili: compattezza, netta separazione tra i caratteri di controllo e quelli grafici, lettere e cifre contigue e ordinate per semplificare l‚Äôordinamento di sequenze alfanumeriche.</p>
<img src="img/unicode/ebcdic.jpg"/>
<p class="illustration">Codifica EBCDIC (fonte <a href="https://www.newton.com.tw/wiki/EBCDIC">newton.com.tw</a>).</p>
<p>Il comitato inizia un lavoro di sintesi della proposta di Bemer e delle codifiche pi√π diffuse dell‚Äôepoca quali CCITT, ITA2 e FIELDATA, oltre alla gi√† citata EBCDIC, che culmina, nei primi mesi del 1963, nella pubblicazione della prima versione dello standard ASCII. Si tratta di una codifica a 7 bit, preferita ad una a 8 per minimizzare i costi di trasmissione.</p>
<img src="img/unicode/ascii_63.gif"/>
<p class="illustration">La versione iniziale della codifica ASCII.</p>
<p>La prima versione della codifica non contempla le lettere minuscole, che tuttavia vengono incluse pochi mesi dopo: la loro posizione √® scelta in modo tale che la configurazione di bit associata ad una lettera minuscola differisce dalla corrispondente versione maisucola per il solo bit in posizione 6, semplificando notevolmente la procedura di trasformazione da maiuscolo a minuscolo di un testo e viceversa. Nel tempo alcuni caratteri di controllo vengono spostati, altri rinominati, altri ancora aggiunti. Il set di caratteri ASCII assume la sua forma definitiva nel 1967. Negli anni successivi lo standard subir√† piccole modifiche atte a risolvere alcune ambiguit√† semantiche, l‚Äôultima delle quali risale al 1986.</p>
<img src="img/unicode/ascii_67_vs_63.gif"/>
<p class="illustration">La versione attuale della codifica ASCII, in evidenza le differenze rispetto alla prima versione.</p>
<p>La codifica ASCII si diffonde molto rapidamente: diversi produttori di apparecchiature per l‚Äôelaborazione dati la scelgono in virt√π della sua compattezza e ricchezza di codici di controllo. Ironicamente, una delle ultime aziende ad adottare questa codifica √® proprio IBM, che decide di servirsene per il suo primo modello di PC nel 1981.</p>
<h3>Curiosit√†</h3>
<p>Come mai il carattere di controllo <span class="code">DEL</span> si trova nell‚Äôangolo in basso a destra della tabella, ben lontano dal resto dei caratteri di controllo? La ragione √® squisitamente fisica:</p>
<blockquote>This code was originally used to mark deleted characters on punched tape, since any character could be changed to all 1s by punching holes everywhere. If a character was punched erroneously, punching out all seven bits caused this position to be ignored or deleted.[2][3] In hexadecimal, this is 7F to rub out 7 bits (FF to rubout 8 bits was used for 8-bit codes). This character could also be used as padding to slow down printing after newlines, though the all-zero NUL was more often used.</blockquote>
<p class="illustratiopn">Fonte: <a href="https://en.wikipedia.org/wiki/Delete_character">wikipedia.org</a>.</p>
<img src="img/unicode/altair_basic.jpg"/>
<p class="illustration">Un nastro perforato.</p>
<h3>Codifica ASCII</h3>
<p>La componente base di una codifica √® il <em>set di caratteri</em>, ovvero l‚Äôinsieme dei simboli che si intende considerare. Il set di caratteri della codifica ASCII comprende tutte le lettere dell‚Äôalfabeto inglese, maiuscole e minuscole, le dieci cifre decimali, i simboli di interpunzione pi√π altri simboli grafici, oltre ad alcuni caratteri di controllo, come ad esempio l‚Äôa-capo. L‚Äôaltro aspetto che caratterizza una codifica √® l‚Äô<em>unit√† di codifica</em>, ovvero l‚Äôunit√† atomica utilizzata per costruire le rappresentazioni dei caratteri; nel caso dell‚ÄôASCII consiste di un pacchetto di 7 bit. Poich√© l‚ÄôASCII attribuisce ad ogni carattere un‚Äôunica unit√† di codifica, e che ad ogni unit√† atomica √® associato un carattere distinto, l‚Äôalfabeto ASCII √® composto esattamente da 128 caratteri, con codici che vanno da <span class="code">0000000</span> (0) fino a <span class="code">1111111</span> (127).</p>
<table cellpadding="0" cellspacing="0" class="ascii">
<tbody><tr><td class="ascii-bit-heading" colspan="4" rowspan="3">Bit Mask</td><td class="ascii-bit-heading">6</td><td class="ascii-bit-6">0</td><td class="ascii-bit-6">0</td><td class="ascii-bit-6">0</td><td class="ascii-bit-6">0</td><td class="ascii-bit-6">1</td><td class="ascii-bit-6">1</td><td class="ascii-bit-6">1</td><td class="ascii-bit-6">1</td></tr>
<tr><td class="ascii-bit-heading">5</td><td class="ascii-bit-5">0</td><td class="ascii-bit-5">0</td><td class="ascii-bit-5">1</td><td class="ascii-bit-5">1</td><td class="ascii-bit-5">0</td><td class="ascii-bit-5">0</td><td class="ascii-bit-5">1</td><td class="ascii-bit-5">1</td></tr>
<tr><td class="ascii-bit-heading">4</td><td class="ascii-bit-4">0</td><td class="ascii-bit-4">1</td><td class="ascii-bit-4">0</td><td class="ascii-bit-4">1</td><td class="ascii-bit-4">0</td><td class="ascii-bit-4">1</td><td class="ascii-bit-4">0</td><td class="ascii-bit-4">1</td></tr>
<tr><td class="ascii-bit-heading" colspan="4">&nbsp;</td><td class="ascii-col-heading">Col‚Üí</td><td class="ascii-col">0</td><td class="ascii-col">1</td><td class="ascii-col">2</td><td class="ascii-col">3</td><td class="ascii-col">4</td><td class="ascii-col">5</td><td class="ascii-col">6</td><td class="ascii-col">7</td></tr>
<tr><th class="ascii-bit-heading">3</th><th class="ascii-bit-heading">2</th><th class="ascii-bit-heading">1</th><th class="ascii-bit-heading">0</th><th>Row‚Üì</th><th colspan="8">&nbsp;</th></tr>
<tr><td class="ascii-bit-3">0</td><td class="ascii-bit-2">0</td><td class="ascii-bit-1">0</td><td class="ascii-bit-0">0</td><td class="ascii-row">0</td><td class="ascii-char">NUL</td><td class="ascii-char">DLE</td><td class="ascii-char">SP</td><td class="ascii-char">0</td><td class="ascii-char">@</td><td class="ascii-char">P</td><td class="ascii-char">`</td><td class="ascii-char">p</td></tr>
<tr><td class="ascii-bit-3">0</td><td class="ascii-bit-2">0</td><td class="ascii-bit-1">0</td><td class="ascii-bit-0">1</td><td class="ascii-row">1</td><td class="ascii-char">SOH</td><td class="ascii-char">DC1</td><td class="ascii-char">!</td><td class="ascii-char">1</td><td class="ascii-char">A</td><td class="ascii-char">Q</td><td class="ascii-char">a</td><td class="ascii-char">q</td></tr>
<tr><td class="ascii-bit-3">0</td><td class="ascii-bit-2">0</td><td class="ascii-bit-1">1</td><td class="ascii-bit-0">0</td><td class="ascii-row">2</td><td class="ascii-char">STX</td><td class="ascii-char">DC2</td><td class="ascii-char">"</td><td class="ascii-char">2</td><td class="ascii-char">B</td><td class="ascii-char">R</td><td class="ascii-char">b</td><td class="ascii-char">r</td></tr>
<tr><td class="ascii-bit-3">0</td><td class="ascii-bit-2">0</td><td class="ascii-bit-1">1</td><td class="ascii-bit-0">1</td><td class="ascii-row">3</td><td class="ascii-char">ETX</td><td class="ascii-char">DC3</td><td class="ascii-char">#</td><td class="ascii-char">3</td><td class="ascii-char">C</td><td class="ascii-char">S</td><td class="ascii-char">c</td><td class="ascii-char">s</td></tr>
<tr><td class="ascii-bit-3">0</td><td class="ascii-bit-2">1</td><td class="ascii-bit-1">0</td><td class="ascii-bit-0">0</td><td class="ascii-row">4</td><td class="ascii-char">EOT</td><td class="ascii-char">DC4</td><td class="ascii-char">$</td><td class="ascii-char">4</td><td class="ascii-char">D</td><td class="ascii-char">T</td><td class="ascii-char">d</td><td class="ascii-char">t</td></tr>
<tr><td class="ascii-bit-3">0</td><td class="ascii-bit-2">1</td><td class="ascii-bit-1">0</td><td class="ascii-bit-0">1</td><td class="ascii-row">5</td><td class="ascii-char">ENQ</td><td class="ascii-char">NAK</td><td class="ascii-char">%</td><td class="ascii-char">5</td><td class="ascii-char">E</td><td class="ascii-char">U</td><td class="ascii-char">e</td><td class="ascii-char">u</td></tr>
<tr><td class="ascii-bit-3">0</td><td class="ascii-bit-2">1</td><td class="ascii-bit-1">1</td><td class="ascii-bit-0">0</td><td class="ascii-row">6</td><td class="ascii-char">ACK</td><td class="ascii-char">SYN</td><td class="ascii-char">&amp;</td><td class="ascii-char">6</td><td class="ascii-char">F</td><td class="ascii-char">V</td><td class="ascii-char">f</td><td class="ascii-char">v</td></tr>
<tr><td class="ascii-bit-3">0</td><td class="ascii-bit-2">1</td><td class="ascii-bit-1">1</td><td class="ascii-bit-0">1</td><td class="ascii-row">7</td><td class="ascii-char">BEL</td><td class="ascii-char">ETB</td><td class="ascii-char">'</td><td class="ascii-char">7</td><td class="ascii-char">G</td><td class="ascii-char">W</td><td class="ascii-char">g</td><td class="ascii-char">w</td></tr>
<tr><td class="ascii-bit-3">1</td><td class="ascii-bit-2">0</td><td class="ascii-bit-1">0</td><td class="ascii-bit-0">0</td><td class="ascii-row">8</td><td class="ascii-char">BS</td><td class="ascii-char">CAN</td><td class="ascii-char">(</td><td class="ascii-char">8</td><td class="ascii-char">H</td><td class="ascii-char">X</td><td class="ascii-char">h</td><td class="ascii-char">x</td></tr>
<tr><td class="ascii-bit-3">1</td><td class="ascii-bit-2">0</td><td class="ascii-bit-1">0</td><td class="ascii-bit-0">1</td><td class="ascii-row">9</td><td class="ascii-char">HT</td><td class="ascii-char">EM</td><td class="ascii-char">)</td><td class="ascii-char">9</td><td class="ascii-char">I</td><td class="ascii-char">Y</td><td class="ascii-char">i</td><td class="ascii-char">y</td></tr>
<tr><td class="ascii-bit-3">1</td><td class="ascii-bit-2">0</td><td class="ascii-bit-1">1</td><td class="ascii-bit-0">0</td><td class="ascii-row">A</td><td class="ascii-char">LF</td><td class="ascii-char">SUB</td><td class="ascii-char">*</td><td class="ascii-char">:</td><td class="ascii-char">J</td><td class="ascii-char">Z</td><td class="ascii-char">j</td><td class="ascii-char">z</td></tr>
<tr><td class="ascii-bit-3">1</td><td class="ascii-bit-2">0</td><td class="ascii-bit-1">1</td><td class="ascii-bit-0">1</td><td class="ascii-row">B</td><td class="ascii-char">VT</td><td class="ascii-char">ESC</td><td class="ascii-char">+</td><td class="ascii-char">;</td><td class="ascii-char">K</td><td class="ascii-char">[</td><td class="ascii-char">k</td><td class="ascii-char">{</td></tr>
<tr><td class="ascii-bit-3">1</td><td class="ascii-bit-2">1</td><td class="ascii-bit-1">0</td><td class="ascii-bit-0">0</td><td class="ascii-row">C</td><td class="ascii-char">FF</td><td class="ascii-char">FS</td><td class="ascii-char">,</td><td class="ascii-char">&lt;</td><td class="ascii-char">L</td><td class="ascii-char">\</td><td class="ascii-char">l</td><td class="ascii-char"></td></tr>
<tr><td class="ascii-bit-3">1</td><td class="ascii-bit-2">1</td><td class="ascii-bit-1">0</td><td class="ascii-bit-0">1</td><td class="ascii-row">D</td><td class="ascii-char">CR</td><td class="ascii-char">GS</td><td class="ascii-char">-</td><td class="ascii-char">=</td><td class="ascii-char">M</td><td class="ascii-char">]</td><td class="ascii-char">m</td><td class="ascii-char">}</td></tr>
<tr><td class="ascii-bit-3">1</td><td class="ascii-bit-2">1</td><td class="ascii-bit-1">1</td><td class="ascii-bit-0">0</td><td class="ascii-row">E</td><td class="ascii-char">SO</td><td class="ascii-char">RS</td><td class="ascii-char">.</td><td class="ascii-char">&gt;</td><td class="ascii-char">N</td><td class="ascii-char">^</td><td class="ascii-char">n</td><td class="ascii-char">~</td></tr>
<tr><td class="ascii-bit-3">1</td><td class="ascii-bit-2">1</td><td class="ascii-bit-1">1</td><td class="ascii-bit-0">1</td><td class="ascii-row">F</td><td class="ascii-char">SI</td><td class="ascii-char">US</td><td class="ascii-char">/</td><td class="ascii-char">?</td><td class="ascii-char">O</td><td class="ascii-char">_</td><td class="ascii-char">o</td><td class="ascii-char">DEL</td></tr>
</tbody></table>
<p>√® immediato ricavare dalla tabella la configurazione di bit per la a maiuscola (carattere <span class="code">A</span>):</p>
<pre class="code">A ‚Üí col=4, row=1
        ‚Üì      ‚Üì
       <span class="bit-6">1</span><span class="bit-5">0</span><span class="bit-4">0</span>     ‚Üì
        ‚Üì    <span class="bit-3">0</span><span class="bit-2">0</span><span class="bit-1">0</span><span class="bit-0">1</span>
        ‚Üì      ‚Üì
       100   0001 = 41
  <span class="bit-pos">bit: 654   3210</span>
</pre>
<h2>Dall‚ÄôASCII alle <em>code page</em> (OEM)</h2>
<p>Poich√© i computer dell‚Äôepoca erano basati su architetture a 8 bit, la memorizzazione di un carattere ASCII in un byte lasciava un bit inutilizzato. Diversi costruttori e sviluppatori di software utilizzarono il bit extra nei modi pi√π disparati, per esempio per indicare un‚Äôenfasi ‚Äì corsivo, grassetto, sottolineatura‚Ä¶ ‚Äì, per indicare il carattere finale di una parola, o per estendere la codifica, introducendo simboli non presenti nella codifica ASCII, come ad esempio le lettere accentate o quelle dell‚Äôalfabeto greco o simboli grafici adatti a realizzare semplici sinottici.</p>
<p>La prima codifica ASCII a 8 bit, denominata ‚ÄúExtended ASCII‚Äù, fu realizzata da IBM per il suo PC nel 1981. La successiva diffusione dei computer IBM-PC compatibili e la necessit√† di localizzare i software spinse verso la standardizzazione delle estensioni proprietarie del codice ASCII, introducendo il concetto di set di caratteri <em>OEM</em> ‚Äì <em>Original Equipment Manufacturer</em>. La costante di questo tipo di codifiche √® l‚Äôuso di unit√† di codifica di 8 bit: le prime 128 posizioni coincidono con quelle del codice ASCII, mentre le successive 128, dal codice <span class="code">1000000</span> (128) al codice <span class="code">11111111</span> (255), sono di volta in volta utilizzate per simboli diversi.</p>
<p>Una particolare mappatura prende il nome di <em>code page</em>, e ogni pagina √® indicata da un identificativo numerico. Per esempio, la pagina contenente le lettere accentate √® la numero 850, mentre quella dedicata all‚Äôalfabeto greco √® la numero 737.</p>
<img src="img/unicode/cp437.gif"/>
<p class="illustration">La code page 437 ‚ÄúUnited States‚Äù, l‚Äôoriginale del PC IBM (fonte: <a href="https://www.charset.org/charsets/us-ascii">charset.org</a>).</p>
<img src="img/unicode/cp850_vs_cp437.gif"/>
<p class="illustration">La code page 850 ‚ÄúMultilingual (Latin I)‚Äù, in evidenza le differenze rispetto alla 437 (fonte: <a href="https://web.archive.org/web/20160307093605/https://msdn.microsoft.com/en-us/goglobal/cc305160">archive.org</a>).</p>
<img src="img/unicode/cp737_vs_cp437.gif"/>
<p class="illustration">La code page 737 ‚ÄúGreek II‚Äù, in evidenza le differenze rispetto alla 437 (fonte: <a href="https://web.archive.org/web/20160316145425/https://msdn.microsoft.com/en-us/goglobal/cc305158">archive.org</a>).</p>
<h2>Code page OEM e ANSI</h2>
<p>Con l‚Äôavvento di Windows nel 1985 Microsoft introdusse delle nuove codifiche, sempre basate su code page. Per distinguerle da quelle OEM usate in ambiente DOS le denomin√≤, piuttosto infelicemente, <em>ANSI</em>: di fatto, non esiste alcuno standard ANSI a riguardo. Microsoft scelse quel nome perch√© nel definire quelle codifiche si ispir√≤ ‚Äì piuttosto liberamente, in realt√† ‚Äì a una proposta di standard che per√≤ non fu mai presa in considerazione dal comitato ANSI, e che qualche anno pi√π tardi sarebbe divenuto l‚ÄôISO-8859-1 (cfr. voce ‚ÄúANSI‚Äù in<sup><a href="#ref-7">[7]</a></sup>). La code page ANSI Windows-1252 e lo standard ISO-8859-1 (noto anche come ‚ÄúLatin 1‚Äù o ‚ÄúWestern Europe‚Äù) differiscono tra loro per ben 27 associazioni<sup><a href="#ref-9">[9]</a></sup>.</p>
<img src="img/unicode/iso-8859-1.gif"/>
<p class="illustration">La code page ISO-8859-1 (fonte: <a href="https://www.charset.org/charsets/iso-8859-1">charset.org</a>).</p>
<img src="img/unicode/windows-1252_vs_iso-8859-1.gif"/>
<p class="illustration">La code page Windows-1252, in evidenza le differenze rispetto all‚ÄôISO 8859-1 (fonte: <a href="https://www.charset.org/charsets/windows-1252">charset.org</a>).</p>
<h2>Ambiguit√† delle <em>code page</em></h2>
<p>Poich√© tutte le codifiche basate su code page estendono quella ASCII, un flusso di testo ASCII √® perfettamente decodificabile utilizzando una qualunque codifica estesa; viceversa, un testo contenente caratteri specifici di una particolare code page OEM o Windows pu√≤ essere decodificato correttamente solo tramite la medesima code page. Questo pu√≤ rappresentare un problema, se il testo viene decodificato su un sistema che usa una code page diversa da quello che l‚Äôha codificato, un fenomeno denominato <em>mojibake</em>, letteramente ‚Äútrasmutazione di caratteri‚Äù:</p>
<table cellpadding="0" cellspacing="0">
<tr><td class="character">c</td><td class="character">a</td><td class="character">f</td><td class="character">f</td><td class="character">√®</td><td></td></tr>
<tr><td class="encoding">‚Üì</td><td class="encoding">‚Üì</td><td class="encoding">‚Üì</td><td class="encoding">‚Üì</td><td class="encoding">‚Üì</td><td class="encoding">CP 850</td></tr>
<tr><td class="byte">63</td><td class="byte">61</td><td class="byte">66</td><td class="byte">66</td><td class="byte">8A</td><td></td></tr>
<tr><td class="encoding">‚Üì</td><td class="encoding">‚Üì</td><td class="encoding">‚Üì</td><td class="encoding">‚Üì</td><td class="encoding">‚Üì</td><td class="encoding">CP 737</td></tr>
<tr><td class="character">c</td><td class="character">a</td><td class="character">f</td><td class="character">f</td><td class="wrong-character">Œõ</td><td></td></tr>
</table>
<p class="illustration">Esempio di mojibake dovuto all‚Äòuso di una code page errata in fase di decodifica.</p>
<h2>Codifiche composte</h2>
<p>Una codifica basata su unit√† a 8 bit che rappresenta ogni carattere con un‚Äôunit√† pu√≤ rappresentare al pi√π 256 caratteri diversi. In alcuni ambiti questo limite √® inaccettabile: le lingue asiatiche ne sono un esempio. Il problema viene normalmente risolto aumentando il numero di unit√† di codifica utilizzate per rappresentare un singolo carattere. Nel caso si scelga di utilizzare due unit√† di codifica per carattere (due byte), si parla di set di caratteri <em>DBCS</em> ‚Äì <em>Double-byte character set</em>. In questo modo, il numero di caratteri rappresentabili sale a 65536. Alcune codifiche DBCS adottano particolari schemi di codifica mista, nelle quali alcuni caratteri vengono associati ad un‚Äôunica unit√† di codifica, altri a due: alla diminuzione del numero di simboli rappresentabili corrisponde per√≤ la possibilit√† di mantenere la compatibilit√† con la codifica ASCII per i caratteri che la prevedono. Queste codifiche non sono compatibili con quelle basate su code page, e ci√≤ preclude la possibilit√† di scambiare informazioni testuali tra due sistemi che adottano due schemi diversi; spesso, anche questa situazione √® inaccettabile.</p>
<h2>Unicode</h2>
<h3>Cenni storici</h3>
<p><em>Unicode</em>, originariamente <em>Unification Code</em>, nasce negli Stati Uniti nella seconda met√† degli anni ‚Äò80 dallo sforzo congiunto di Xerox e Apple di definire un set di caratteri multi-lingua facilmente trattabile dai calcolatori, in particolare astraendo dalle code page e scegliendo un‚Äôunit√† di codifica a lunghezza fissa di 16 bit. I limiti di questa scelta si palesarono pochi anni pi√π tardi, quando il processo di standardizzazione delle lingue orientali produsse un catalogo di decine di migliaia ideogrammi: un alfabeto troppo ampio per poter essere interamente rappresentato con una codifica a 16 bit.</p>
<p>Contemporaneamente in Europa nasceva lo standard ISO/IEC 10646, che introduceva una codifica a 32 bit nota come <em>UCS</em> ‚Äì <em>Universal (Coded) Character Set</em> che, prevedendo delle sequenze di <em>escape</em> per attivare delle modalit√† di codifica differenti, rendeva praticamente infinito il numero di caratteri rappresentabili.</p>
<p>Oltre che per l‚Äòestensione del set di caratteri coperto, le due codifiche si differenziavano anche per altri aspetti sostanziali:</p>
<ul>
<li>ISO/IEC 10646 contemplava ben tre rappresentazioni binarie differenti dei codici attribuiti ai caratteri della codifica: UCS-4, UCS-2 e UCS-1;</li>
<li>Unicode definiva non solo la corrispondenza tra un carattere e il suo codice identificativo, ma anche le regole di ordinamento dei caratteri stessi (che in genere dipendono dalla lingua), i criteri di equivalenza delle sequenze di caratteri (con concetti quali <em>normalizzazione, composizione e decomposizione</em>), quelle di segmentazione (con concetti quali <em>word/sentence boundary</em>) nonch√© gli algoritmi per il trattamento dei testi bidirezionali.</li>
</ul>
<p>Agli inizi degli anni ‚Äò90 ebbe inizio un processo di unificazione delle due codifiche: gi√† in Unicode 2.0 appaiono tre differenti codifiche binarie di chiara ispirazione ISO. Le attribuzioni dei codici della versione 6.1 di Unicode corrispondono perfettamente a quelle definite dallo standard ISO/IEC 10646:2012.</p>
<h4>Eventi principali e curiosit√†</h4>
<ul>
<li><strong>1987</strong>: Xerox ed Apple iniziano lo studio di un set di caratteri universale;</li>
<li><strong>1988</strong>: viene pubblicato il documento Unicode 88 che contiene una proposta per un <em>‚Äúinternational/multilingual text character encoding system‚Äù</em> codificato su 16 bit;</li>
<li><strong>1990</strong>: viene presentata la bozza finale di Unicode 1.0;</li>
<li><strong>1991</strong>: il 3 gennaio nasce in California lo Unicode Consortium;</li>
<li><strong>1991</strong>: a ottobre viene pubblicato Unicode 1.0; nell‚Äôintroduzione si legge:
<blockquote>With over 30,000 unallocated character positions, the Unicode character encoding provides sufficient space for foreseeable future expansion.</blockquote></li>
<li><strong>1996</strong>: Unicode 2.0 introduce i surrogati per superare il limite dei 16 bit.</li>
<li><strong>2010</strong>: Unicode 6.0 accoglie le prime emoticon ed emoji.</li>
<li><strong>2017</strong>: Unicode 10.0 include il simbolo U+20BF (‚Çø) del Bitcoin.</li>
<li><strong>2025</strong>: Unicode 17.0 √® la versione pi√π recente ad oggi pubblicata.</li>
</ul>
<h3>Evoluzione di Unicode</h3>
<p>Unicode √® in continuo sviluppo:</p>
<img src="img/unicode/unicode_evolution.png"/>
<p class="illustration">Scritture e caratteri supportati da Unicode nel tempo.</p>
<h3>Diffusione di Unicode</h3>
<p>Unicode conobbe un immediato successo, in particolare sul Web:</p>
<img src="img/unicode/unicode_web.png"/>
<p class="illustration">Diffusione di Unicode in Internet nei primi anni 2000 (fonte: <a href="https://googleblog.blogspot.com/2012/02/unicode-over-60-percent-of-web.html">googleblog.blogspot.com</a>).</p>
<h3>Code point e <em>piani</em></h3>
<p>Ad ogni carattere Unicode assegna un <em>code point</em>, ovvero un valore numerico compreso tra <span class="code">0</span> e <span class="code">10FFFF</span> cui viene applicato il prefisso <span class="code">U+</span> (il code point della lettera A maiuscola √® <span class="code">U+0041</span>). Non tutti i code point sono assegnati ad un carattere. La codifica √® strutturata in <em>piani</em>, ognuno dei quali contiene 65536 caratteri. I piani definiti sono 16, e sono identificati dalle prime due cifre del codice esadecimale. I caratteri originali Unicode a 16 bit, i cui codici sono compresi tra <span class="code">0</span> e <span class="code">00FFFF</span>, costituiscono il <em>piano zero</em> o <em>BMP</em> ‚Äì <em>Basic Multilingual Plan</em>. I piani successivi sono detti <em>piani estesi</em> o <em>piani surrogati</em>. Se i caratteri del piano zero sono rappresentabili con 16 bit, quelli dei piani estesi necessitano di almeno 24 bit. Codificare caratteri con sequenze di lunghezza diversa pu√≤ essere problematico, come gi√† visto. D‚Äôaltra parte, anche utilizzare pi√π bit del necessario per rappresentare i caratteri ha i suoi svantaggi.</p>
<table cellpadding="0" cellspacing="0">
<tbody><tr><th>Piano</th><th>Intervallo</th><th>Descrizione</th><th>Abbreviazione</th></tr>
<tr><td>00</td><td>000000-00FFFF</td><td>Basic Multilingual Plane</td><td>BMP</td></tr>
<tr><td>01</td><td>010000-01FFFF</td><td>Supplementary Multilingual Plane</td><td>SMP</td></tr>
<tr><td>02</td><td>020000-02FFFF</td><td>Supplementary Ideographic Plane</td><td>SIP</td></tr>
<tr><td>03</td><td>030000-03FFFF</td><td>Tertiary Ideographic Plane</td><td>TIP</td></tr>
<tr><td>04-13</td><td>040000-0DFFFF</td><td>non assegnati</td><td>-</td></tr>
<tr><td>14</td><td>0E0000-0EFFFF  </td><td>Supplementary Special-purpose Plane</td><td>SSP</td></tr>
<tr><td>15</td><td>0F0000-0FFFFF</td><td>Supplementary Private Use Area-A</td><td>-</td></tr>
<tr><td>16</td><td>100000-10FFFF</td><td>Supplementary Private Use Area-B</td><td>-</td></tr>
</tbody></table>
<h3>Caratteri</h3>
<p>Il carattere in Unicode √® un‚Äôentit√† astratta, indipendente dalla sua forma grafica (<em>glifo</em>); esso rappresenta un‚Äôunit√† di testo (<em>grafeme</em>). In quest‚Äôottica, Unicode associa un code point alla <em>descrizione</em> di un carattere, senza entrare nel merito dell‚Äôaspetto (corsivo, grassetto, con o senza le grazie, ‚Ä¶). Ad esempio, il code point <span class="code">U+0041</span> √® associato al carattere <em>LATIN CAPITAL LETTER A</em>, ed √® solo per motivi di praticit√† che nelle tabelle di codifica viene anche riportato un esempio di rappresentazione grafica del carattere.</p>
<h4>Equivalenza</h4>
<p>In genere non c‚Äô√® corrispondenza biunivoca tra grafemi e glifi: un unico grafeme pu√≤ essere composto da pi√π glifi (ad esempio la lettera e accentata pu√≤ essere considerata come una composizione di due glifi, quello per la e e quello per l'accento), cos√¨ come un glifo pu√≤ rappresentare pi√π grafemi (si pensi ad esempio alle legature). Per ragioni di compatibilit√†, anche la codifica Unicode non √® biunivoca: un singolo carattere pu√≤ essere identificato da sequenze di altri caratteri; si parla in questo caso di caratteri <em>equivalenti</em>. Esistono due tipi di equivalenze:</p>
<dl>
<dt>equivalenza canonica</dt><dd>caratteri o sequenze di caratteri che rappresentano lo stesso simbolo astratto e che sono graficamente indistinguibili; un esempio sono i caratteri ottenibili per composizione:
<pre class="code">U+00E8 - LATIN SMALL LETTER E WITH GRAVE..........√®

U+0065 - LATIN SMALL LETTER E.....................e
U+0300 - COMBINING GRAVE ACCENT...................ÃÄ&nbsp;

U+00E8 (√®) ‚â°  U+0065 U+0300 (eÃÄ)
</pre>
<p>Un caso di equivalenza canonica ternaria:</p>
<pre class="code">U+00C5 - LATIN CAPITAL LETTER A WITH RING ABOVE...√Ö

U+0041 - LATIN CAPITAL LETTER A...................A
U+030A - COMBINING RING ABOVE.....................Ãä&nbsp;

U+212B - ANGSTROM SIGN............................‚Ñ´

U+00C5 (√Ö) ‚â° U+0041 U+030A (AÃä) ‚â° U+212B (‚Ñ´)
</pre>
</dd>
<dt>equivalenza di compatibilit√†</dt><dd>caratteri o sequenze di caratteri che rappresentano lo stesso simbolo astratto ma che si distinguono per forma o altre caratteristiche; sono comprese le varianti grafiche, gli apici, i pedici, le legature, ‚Ä¶:
<pre class="code">U+2460 CIRCLED DIGIT ONE..........................‚ë†
U+0031 DIGIT ONE..................................1

U+2460 (‚ë†) ‚àº U+0031 (1)


U+2083 - SUBSCRIPT THREE..........................‚ÇÉ
U+0033 - DIGIT THREE..............................3

U+2083 (‚ÇÉ) ‚àº U+0033 (3)


U+FB01 - LATIN SMALL LIGATURE FI..................Ô¨Å

U+0066 - LATIN SMALL LETTER F.....................f
U+0069 - LATIN SMALL LETTER I.....................i

U+FB01 (Ô¨Å) ‚àº U+0066 U+0069 (fi)
</pre></dd>
</dl>
<p>Poich√© uno stesso carattere pu√≤ assumere codifiche differenti, nasce il problema di stabilire, dati due testi Unicode, se questi sono uguali. A tal scopo sono state definite delle regole di normalizzazione delle rappresentazioni dei testi Unicode ‚Äì <em>Unicode Normalization Forms<sup><a href="#ref-10">[10]</a></sup></em> ‚Äì che si occupano di trasformare i testi originali in una forma primitiva comune, a partire dalla quale risulta pi√π semplice effettuare il confronto.</p>
<h3>Separazione tra codifica e rappresentazione binaria</h3>
<p>Se da una parte Unicode associa ad ogni carattere un codice univoco, dall‚Äôaltra offre la possibilit√† di scegliere il formato di rappresentazione binaria dei codici (<em>UTF</em> ‚Äì <em>Unicode/UCS Transformation Format</em>), variabile o fissa:</p>
<ul>
<li><p><em>UTF-8</em>: codifica multi-byte a lunghezza variabile con unit√† di codifica a 8 bit, ASCII-compatibile; rappresenta ogni carattere con un minimo di 1 ad un massimo di 4 byte. E‚Äô una codifica <em>stateless</em>, ovvero gli errori di codifica di un carattere non si propagano ai successivi;</p></li>
<li><p><em>UTF-16</em>: codifica multi-byte a lunghezza variabile con unit√† di codifica a 16 bit; ogni carattere √® rappresentato con una sequenza di 2 o 4 byte. Esiste nelle varianti <em>big endian</em> (<em>UTF-16BE</em>) e <em>little endian</em> (<em>UTF-16LE</em>);</p></li>
<li><p><em>UTF-32</em>: codifica multi-byte a lunghezza fissa con unit√† di codifica a 32 bit; ogni carattere √® rappresentato con una sequenza di 4 byte. Esiste nelle varianti <em>big endian</em> (<em>UTF-32BE</em>) e <em>little endian</em> (<em>UTF-32LE</em>).</p></li>
</ul>
<p>La tabella sottostante riporta il numero di byte necessario per rappresentare un code point nei vari formati:</p>
<table cellpadding="0" cellspacing="0">
<tbody><tr><th>Intervallo</th><th>Caratteri contenuti</th><th>UTF-32</th><th>UTF-16</th><th>UTF-8</th></tr>
<tr><td>000000-00007F</td><td>Basic Latin</td><td class="byte-count">4</td><td class="byte-count">2</td><td class="byte-count">1</td></tr>
<tr><td>000080-0007FF</td><td>Latin Extensions, Greek, Cyrillic, ‚Ä¶</td><td class="byte-count">4</td><td class="byte-count">2</td><td class="byte-count">2</td></tr>
<tr><td>000800-00FFFF</td><td>Thai, Hiragana, Katakana, ‚Ä¶</td><td class="byte-count">4</td><td class="byte-count">2</td><td class="byte-count">3</td></tr>
<tr><td>010000-10FFFF</td><td>Cuneiform, Hieroglyphs, Private, ‚Ä¶</td><td class="byte-count">4</td><td class="byte-count">4</td><td class="byte-count">4</td></tr>
</tbody></table>
<h4>Endianness</h4>
<p>Quando una sequenza di caratteri Unicode in formato UTF-16 o UTF-32 viene serializzata in un flusso di byte, per esempio un file, √® necessario definire l‚Äôordine di scrittura dei byte che costituiscono le singole unit√† di codifica. La rappresentazione UTF-16 della lettera A maiuscola, <span class="code">0041</span>, pu√≤ ad esempio essere serializzata in due modi distinti: <span class="code">00</span>‚Äì<span class="code">41</span> oppure <span class="code">41</span>‚Äì<span class="code">00</span>. La prima forma, presentando prima il byte pi√π significativo seguito da quello meno significativo, viene detta <em>big endian</em>; la seconda forma, nella quale il byte meno significativo precede quello pi√π significativo, viene denominata <em>little endian</em>. L‚Äô<em>endianness</em> indica quindi il ‚Äúpeso‚Äù del primo byte che si incontra.</p>
<h4>Peculiarit√† della codifica UTF-16</h4>
<p>La codifica UTF-16 fa uso di alcuni speciali code point del Basic Multilingual Plan, denominati <em>surrogati</em>, per indirizzare i caratteri al di fuori del BMP stesso. I surrogati sono 2048 code point che non corrispondono a nessun carattere, e si suddividono in <em>surrogati alti</em>, i cui codici vanno da <span class="code">U+D800</span> fino a <span class="code">U+DBFF</span>, e <em>surrogati bassi</em>, da <span class="code">U+DC00</span> a <span class="code">U+DFFF</span>. I surrogati appaiono sempre in coppia, nell‚Äôordine alto/basso.</p>
<p>La coppia di surrogati viene determinata sottraendo <span class="code">10000</span> dal code point del carattere cos√¨ da normalizzarlo nell‚Äôintervallo [<span class="code">0</span>, <span class="code">FFFFF</span>]; i venti bit rimanenti vengono equamente distribuiti nei dieci bit meno significativi del surrogato alto (<span class="code">D800</span>√∑<span class="code">DBFF</span> ‚Üî <span class="code">110110xxxxxxxxxx</span>) e quello basso (<span class="code">DC00</span>√∑<span class="code">DFFF</span> ‚Üî <span class="code">110111xxxxxxxxxx</span>):</p>
<pre class="code">U+1D54A - MATHEMATICAL DOUBLE-STRUCK CAPITAL S....ùïä

1D54A ‚Üí 0001 1101 0101 0100 1010 -
        0001 0000 0000 0000 0000
        ========================
        0000 1101 0101 0100 1010
             ‚Üì           ‚Üì
         0000110101  0101001010
             ‚Üì           ‚Üì
   110110xxxxxxxxxx      ‚Üì
          ‚Üì              ‚Üì
   1101100000110101      ‚Üì
          ‚Üì              ‚Üì
         D835            ‚Üì
               110111xxxxxxxxxx
                      ‚Üì
               1101110101001010
                      ‚Üì
                     DD4A

U+1D54A ‚Üí D835 DD4A
</pre>
<h4>Peculiarit√† della codifica UTF-8</h4>
<p>La codifica UTF-8 distribuisce i bit di un code point in una sequenza di byte secondo lo schema seguente:</p>
<table cellpadding="0" cellspacing="0">
<tbody><tr><th>Intervallo</th><th>Bits</th><th>Maschera</th></tr>
<tr><td>000000-00007F</td><td>7</td><td class="bit-mask">0xxxxxxx</td></tr>
<tr><td>000080-0007FF</td><td>11</td><td>110xxxxx 10xxxxxx</td></tr>
<tr><td>000800-00FFFF</td><td>16</td><td>1110xxxx 10xxxxxx 10xxxxxx</td></tr>
<tr><td>010000-10FFFF</td><td>21</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td></tr>
</tbody></table>
<p>La configurazione dei bit pi√π significativi dei byte costituenti di una codifica UTF-8 assumono dunque un significato ben preciso:</p>
<table cellpadding="0" cellspacing="0">
<tbody><tr><th>Bits</th><th>Significato</th></tr>
<tr><td>0xxxxxxx</td><td>Byte iniziale di una sequenza di lunghezza 1 (ASCII)</td></tr>
<tr><td>10xxxxxx</td><td>Byte successivo al primo</td></tr>
<tr><td>110xxxxx</td><td>Byte iniziale di una sequenza di lunghezza 2</td></tr>
<tr><td>1110xxxx</td><td>Byte iniziale di una sequenza di lunghezza 3</td></tr>
<tr><td>11110xxx</td><td>Byte iniziale di una sequenza di lunghezza 4</td></tr>
</tbody></table>
<p>Segue un esempio di codifica UTF-8:</p>
<pre class="code">U+2135 - ALEF SYMBOL..............................‚Ñµ

2135 ‚Üí 0010 0001 0011 0101

       0010 0001 0011 0101 ‚Üí 0010   000100   110101
                              ‚Üì       ‚Üì        ‚Üì
                         1110xxxx 10xxxxxx 10xxxxxx
                            ‚Üì        ‚Üì        ‚Üì
                         11100010 10000100 10110101
                            ‚Üì        ‚Üì        ‚Üì
                            E2       84       B5

U+2135 ‚Üí E2 84 B5
</pre>
<h3>Formato UTF e UCS</h3>
<p>Anche l‚ÄôISO/IEC 10646 specifica delle forme di codifica:</p>
<ul>
<li><p><em>UCS-4</em>: <em>‚ÄúUniversal Character Set coded in 4 octets‚Äù</em>, equivale a UTF-32, ed √® la forma canonica di rappresentazione dei caratteri;</p></li>
<li><p><em>UCS-2</em>: <em>‚ÄúUniversal Character Set coded in 2 octets‚Äù</em>, noto anche come <em>‚Äúthe two-octet BMP form‚Äù</em>, rappresenta i soli caratteri del piano zero, ovvero quei caratteri rappresentabili con un‚Äôunica unit√† di 32 bit. In questo contesto, √® compatibile con UTF-16. E‚Äô stato dichiarato obsoleto nel 2011.</p></li>
</ul>
<h3>Il BOM</h3>
<p>Il <em>BOM</em> ‚Äì <em>Byte order mark</em> √® il carattere Unicode <span class="code">U+FEFF</span> quando utilizzato per specificare l‚Äô<em>endianness</em> di una sequenza di caratteri Unicode. Tale carattere, denominato <em>‚Äúzero width no-break space‚Äù</em>, pu√≤ occupare solo la prima posizione di una sequenza di caratteri Unicode e non ha altro effetto che quello di fornire un‚Äôindicazione indiretta del tipo di ordinamento in uso ‚Äî perdendo quindi il significato originale di ‚Äúzero width no-break space‚Äù.</p>
<p><em>Nota</em>: il vincolo di poter apparire solo in prima posizione √® stato introdotto nella versione 3.2 di Unicode. Non √® quindi escluso che si possa trovare anche in posizioni intermedie, dove di nuovo assume il significato di ‚Äúzero width no-break space‚Äù. In questo contesto andrebbe sostituito dal carattere <span class="code">U+2060</span> <em>‚Äúword joiner‚Äù</em>.</p>
<table cellpadding="0" cellspacing="0">
<tbody><tr><th>Codifica</th><th>Endianness</th><th>BOM ammesso?</th></tr>
<tr><td>UTF-8</td><td class="endianness">n/a</td><td class="bom">s√¨</td></tr>
<tr><td>UTF-16</td><td class="endianness">?</td><td class="bom">s√¨</td></tr>
<tr><td>UTF-16BE</td><td class="endianness">big</td><td class="bom">no</td></tr>
<tr><td>UTF-16LE</td><td class="endianness">little</td><td class="bom">no</td></tr>
<tr><td>UTF-32</td><td class="endianness">?</td><td class="bom">s√¨</td></tr>
<tr><td>UTF-32BE</td><td class="endianness">big</td><td class="bom">no</td></tr>
<tr><td>UTF-32LE</td><td class="endianness">little</td><td class="bom">no</td></tr>
</tbody></table>
<h4>Il BOM nell‚ÄôUTF-8</h4>
<p>Utilizzando unit√† di codifica a 8 byte, in linea di principio la presenza del BOM √® superflua; alcuni software tuttavia la potrebbero richiedere. Il BOM in UTF-8 √® rappresentato dalla sequenza <span class="code">EF BB BF</span>.</p>
<h4>Il BOM nell‚ÄôUTF-16</h4>
<p>Se durante la decodifica di un flusso Unicode la prima coppia di byte incontrata √® <span class="code">FE FF</span>, si pu√≤ presupporre che si tratti del BOM di una sequenza big endian. Se invece si trova <span class="code">FF FE</span>, essendo il code point <span class="code">U+FFFE</span> non valido, si pu√≤ presupporre che si tratti del BOM di una sequenza little endian. In genere, se un flusso binario inizia con la sequenza <span class="code">FF FE</span> o <span class="code">FE FF</span> si pu√≤ ragionevolmente presupporre che si tratti di testo Unicode UTF-16.</p>
<h4>Il BOM nell‚ÄôUTF-32</h4>
<p>Valgono le stesse considerazioni fatte per l‚ÄôUTF-16.</p>
<h3>Trasformazione maiuscolo/minuscolo</h3>
<p>Per la stragrande maggioranza dei caratteri Unicode la trasformazione da maiuscolo a minuscolo (e viceversa) comporta la sosituzione di un code point con un altro. Questi casi sono definiti ‚Äúsimple case mappings‚Äù e le corrispondenze sono elencate nello standard. Esistono tuttavia dei casi in cui la trasformazione richiede particolari attenzioni: questi vanno sotto il nome di ‚Äúspecial case mappings‚Äù e sono definiti in un documento apposito. Segue qualche esempio.</p>
<h4>Numero di code point difformi</h4>
<ul>
<li><p>la ‚Äús tedesca‚Äù:</p>
<pre class="code">
U+00DF ‚Üî U+0053 U+0053

U+00DF - LATIN SMALL LETTER SHARP S..............√ü
U+0053 - LATIN CAPITAL LETTER S..................S

√ü ‚Üî SS
</li>
<li><p>le legature:</p>
<pre class="code">
U+00DF ‚Üî U+0046 U+0049

U+FB01 - LATIN SMALL LIGATURE FI.................Ô¨Å
U+0046 - LATIN CAPITAL LETTER F..................F
U+0049 - LATIN CAPITAL LETTER I..................I

Ô¨Å ‚Üî FI
</li>
<li><p>caratteri privi del corrispettivo maiuscol/minuscolo:</p>
<pre class="code">
U+1E97 ‚Üî U+0054 U+0308

U+1E97 - LATIN SMALL LETTER T WITH DIAERESIS.....·∫ó
U+0054 - LATIN CAPITAL LETTER T..................T
U+0308 - COMBINING DIAERESIS.....................‚óåÃà

·∫ó ‚Üî T‚óåÃà
</li>
</ul>
</pre>
<h4>Casi dipendenti dal contesto</h4>
<ul>
<li><p>Sigma in coda:</p>
<pre class="code">
U+03C2 ‚Üî U+03A3
U+03C3 ‚Üî U+03A3

U+03C2 - GREEK SMALL LETTER FINAL SIGMA..........œÇ
U+03C3 - GREEK SMALL LETTER SIGMA................œÉ
U+03A3 - GREEK CAPITAL LETTER SIGMA..............Œ£

œÇ ‚Üî Œ£ (for final sigma)
œÉ ‚Üî Œ£ (for non-final sigma)
</li>
<li><p>Lettera i minuscola in turco:</p>
<pre class="code">
U+0069 ‚Üî U+0049
U+0069 ‚Üî U+0130 [tr]

U+0069 - LATIN SMALL LETTER I....................i
U+0049 - LATIN CAPITAL LETTER I..................I
U+0130 - LATIN CAPITAL LETTER I WITH DOT ABOVE...ƒ∞

i ‚Üî I
i ‚Üî ƒ∞ (in Turkish)
</li>
</ul>
<a name="mojibake"></a>
<h3>Mojibake Unicode/ANSI</h3>
<p>Ancora oggi ci si pu√≤ imbattere nel mojibake, tipicamente su un Windows quando un testo codificato UTF-8 viene visualizzato utilizzando la code page ANSI attiva in quel momento. Per esempio, la parola <em>caff√®</em>, che corrisponde alla sequenza di code point Unicode:</p>
<pre class="code">caff√® ‚Üí U+0063 U+0061 U+0066 U+0066 U+00E8
</pre>
<p>se codificata in UTF-8 origina la sequenza di byte:</p>
<pre class="code">caff√® ‚Üí 63 61 66 66 C3 A8
</pre>
<p>Questa stessa sequenza, se decodificata utilizzando la code page Windows-1252, d√† luogo alla ‚Äúparola‚Äù:</p>
<pre class="code">63 61 66 66 C3 A8 ‚Üí caff√É¬®
</pre>
<p>Viceversa, la codifica secondo la code page Windows-1252 della parola originale corrisponde a:</p>
<pre class="code">caff√® ‚Üí 63 61 66 E8
</pre>
<p>che decodificata in UTF-8 produce:</p>
<pre class="code">63 61 66 E8 ‚Üí caffÔøΩ
</pre>
<p>Il carattere ÔøΩ (<em>‚Äúreplacement character‚Äù</em>, code point <span class="code">U+FFFD</span>) √® il simbolo convenzionalmente utilizzato da Unicode per segnalare la presenza di un code point sconosciuto o non rappresentabile.</p>
<h3>Curiosit√†</h3>
<p>In Python 3.x, la cui conformit√† a Unicode √® rimarchevole, accade questo (font permettendo):</p>
<pre class="code">&gt;&gt;&gt; int("‡ß™‡≠®")
<strong>42</strong>
</pre>
<p>La risposta risulta meno sorprendente se si considera l‚Äôespressione seguente, equivalente alla prima:</p>
<pre class="code">&gt;&gt;&gt; int("\u09ea\u0b68")
<strong>42</strong>
</pre>
<p>La consultazione delle tabelle Unicode risolve il mistero:</p>
<pre class="code">U+09EA - BENGALI DIGIT FOUR.......................‡ß™
U+0B68 - ORIYA DIGIT TWO..........................‡≠®
</pre>
<p class="update"><strong>Aggiornamento [28/05/2014]</strong></p>
<p>Al <a href="http://cppnow.org/">C++Now 2014</a> c‚Äô√® stato un intervento di James McNellis intitolato ‚ÄúUnicode in C++‚Äù; le <a href="https://github.com/boostcon/cppnow_presentations_2014/blob/master/files/unicode-cpp.pdf?raw=true">slide</a> che ha preparato sono splendide, tanto che ne ho fatto una <a href="https://gzuliani.github.io/unicode/files/unicode/unicode-cpp.pdf">copia locale</a> per non rischiare di perderle!</p>
<h2>Riferimenti</h2>
<ol>
<li class="ref"><a name="ref-1"></a>Cimarosti, M. <em>‚ÄúDodici anni di Unicode‚Äù</em> ‚Äî <a href="http://web.tiscali.it/marco.cimarosti/pro_graf.html">http://web.tiscali.it/marco.cimarosti/pro_graf.html</a>, visitato il 07/06/2013</li>
<li class="ref"><a name="ref-2"></a>Kuhn, M. <em>‚ÄúUTF-8 and Unicode FAQ for Unix/Linux‚Äù</em> ‚Äî <a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html">http://www.cl.cam.ac.uk/~mgk25/unicode.html</a>, visitato il 05/06/2013</li>
<li class="ref"><a name="ref-3"></a>Searle, S. <em>‚ÄúA Brief History of Character Codes‚Äù</em> ‚Äî <a href="http://tronweb.super-nova.co.jp/characcodehist.html">http://tronweb.super-nova.co.jp/characcodehist.html</a></li>
<li class="ref"><a name="ref-4"></a>Spolsky, J. <em>‚ÄúThe Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)‚Äù</em>, joelonsoftware.com ‚Äî <a href="http://www.joelonsoftware.com/articles/Unicode.html">http://www.joelonsoftware.com/articles/Unicode.html</a>, visitato il 05/06/2013</li>
<li class="ref"><a name="ref-5"></a><em>‚ÄúA Technical Introduction‚Äù</em>, The Unicode Consortium ‚Äî <a href="http://www.unicode.org/standard/principles.html">http://www.unicode.org/standard/principles.html</a>, visitato il 07/06/2013</li>
<li class="ref"><a name="ref-6"></a><em>‚ÄúASCII format for Network Interchange‚Äù</em> ‚Äî <a href="http://tools.ietf.org/rfc/rfc20.txt">http://tools.ietf.org/rfc/rfc20.txt</a>, visitato il 05/06/2013</li>
<li class="ref"><a name="ref-7"></a><em>‚ÄúGlobal Development Center‚Äôs Glossary</em>‚Äù, microsoft.com ‚Äî <a href="http://msdn.microsoft.com/en-us/goglobal/bb964658.aspx#a">http://msdn.microsoft.com/en-us/goglobal/bb964658.aspx#a</a>, visitato il 05/06/2013</li>
<li class="ref"><a name="ref-8"></a><em>‚ÄúMicrosoft OEM (DOS) Code Pages‚Äù</em>, Character Sets And Code Pages At The Push Of A Button ‚Äî <a href="http://msdn.microsoft.com/en-us/goglobal/bb964658.aspx#a">http://msdn.microsoft.com/en-us/goglobal/bb964658.aspx#a</a>, visitato il 05/06/2013</li>
<li class="ref"><a name="ref-9"></a><em>‚ÄúWindows-1252‚Äù</em>, wikipedia.org ‚Äî <a href="https://en.wikipedia.org/wiki/Windows-1252">https://en.wikipedia.org/wiki/Windows-1252</a>, visitato il 05/06/2013</li>
<li class="ref"><a name="ref-10"></a><em>‚ÄúUnicode Standard Annex #15 - UNICODE NORMALIZATION FORMS‚Äù</em>, The Unicode Consortium ‚Äî <a href="http://unicode.org/reports/tr15/">http://unicode.org/reports/tr15/</a>, visitato il 07/06/2013</li>
<li class="ref"><a name="ref-11"></a><em>‚ÄúUTF-8 encoding table and Unicode characters‚Äù</em>, utf8-chartable.de ‚Äî <a href="http://www.utf8-chartable.de/unicode-utf8-table.pl">http://www.utf8-chartable.de/unicode-utf8-table.pl</a></li>
<li class="ref"><a name="ref-12"></a><em>‚ÄúUTF-8 Sampler‚Äù</em>, columbia.edu ‚Äî <a href="http://www.columbia.edu/~fdc/utf8/">http://www.columbia.edu/~fdc/utf8/</a></li>
</ol>
<p class="modification-notice">Pagina modificata il 08/11/2025</p>
</body></html>