<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<title>Accelerometro grafico con arduino</title>
<link href="../css/main.css" rel="stylesheet" type="text/css"/>
<link href="css/arduino-mpu6050-oled.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<p class="page-path"><a href="../index.html#arduino-mpu6050-oled">risorse</a> | accelerometro grafico con arduino</p>
<h1>Accelerometro grafico con Arduino</h1>
<p class="disclaimer"><strong>Attenzione:</strong> ho posto la massima cura ed attenzione nel redigere questi appunti; declino tuttavia ogni responsabilità per eventuali imprecisioni, errori od omissioni, così come declino ogni responsabilità per eventuali danni a cose, proprietà o persone derivanti dall’uso di questi contenuti.</p>
<p>Una volta completato il <a href="arduino-mpu6050.html">progetto dell'accelerometro</a>, un amico mi ha suggerito di realizzarne una versione grafica in cui i valori di accelerazione lungo gli assi x e y sono rappresentati dalla posizione di un punto su di un diagramma cartesiano:</p>
<img src="img/arduino-mpu6050-oled/graphic-accelerometer.png">
<p class="illustration">Un accelerometro grafico</p>
<p>In commercio si trovano diversi display OLED monocromatici di piccolo formato facilmente interfacciabili con Arduino. Ne ho acquistato uno di 0,96 pollici di diagonale con una risoluzione di 128x64 pixel, compatibile con il display SSD1603 prodotto da Adafruit, per poco più di 5 Euro su Amazon:</p>
<img src="img/arduino-mpu6050-oled/display.jpg">
<p class="illustration">Il display OLED acquistato</p>
<p>Oltre al costo irrisorio, il display ha il vantaggio di poter essere pilotato tramite il bus I2C di Arduino sfruttando le librerie sviluppate per il display originale.</p>
<h2>Cablaggio</h2>
<p>La connessione al bus I2C richiede solamente i connettori per i canali <span class="pin">SCL</span> e <span class="pin">SDA</span>, linee di alimentazione escluse. Il display può essere collegato in cascata all'accelerometro:</p>
<img src="img/arduino-mpu6050-oled/wiring-mpu5060-display.png">
<p class="illustration">Connessione del display al bus I2C del circuito dell'accelerometro</p>
<img src="img/arduino-mpu6050-oled/circuit-mpu5060-display.jpg">
<p class="illustration">Realizzazione pratica del circuito</p>
<p>Per verificare la corretta cablatura del circuito conviene effettuare uno scan del bus I2C (cfr. appunti <a href="arduino-mpu6050.html#verifica-cablaggio">accelerometro con arduino</a>); se tutto funziona correttamente, lo scanner dovrebbe individuare due dispositivi distinti, l'accelerometro e il display:</p>
<pre class="code">
Scanning IC2 bus...
IC2 device found at address 0x3C
IC2 device found at address 0x68
Scanning completed, waiting for another run...
</pre>
<p>Il dispositivo di indirizzo <span class="address">0x68</span> è l'accelerometro, l'altro &ndash; <span class="address">0x3C</span> &ndash; è il display.</p>
<h2>Librerie di supporto</h2>
<p>Esistono diverse librerie per il controllo del display; quelle di interesse sono:</p>
<ul>
<li><span class="library">Adafruit GFX Library</span><a href="ref-2"><sup>[2]</sup></a>: libreria grafica di base, indipendente dall'hardware;</li>
<li><span class="library">Adafruit SSD1306</span><a href="ref-3"><sup>[3]</sup></a>: driver per il display OLED in uso.</li>
</ul>
<p>Le librerie possono essere installate direttamente dall'IDE di Arduino:</p>
<ol>
<li>aprire la maschera di gestione delle librerie con il comando <span class="menu">Sketch</span> &rarr; <span class="menu">Include Library</span> &rarr; <span class="menu">Manage Libraries...</span>;</li>
<li>selezionare la versione più recente della libreria di interesse (1.1.5 per <span class="library">Adafruit GFX Library</span>, 1.1.2 per <span class="library">Adafruit SSD1306</span>);</li>
<li>attendere il <em>download</em> e l'installazione della libreria;</li>
<li>procedere con la libreria successiva.</li>
</ol>
<p>Al termine della procedura, come controprova dell'avvenuta installazione si può utilizzare lo sketch che dimostra le possibilità del display. Dal menu <span class="menu">File</span> &rarr; <span class="menu">Examples</span> &rarr; <span class="menu">Adafruit SSD1306</span> selezionare lo sketch <span class="menu">ssd1306_128x64_i2c</span>, avendo cura di impostare l'indirizzo corretto del display sostituendo alla riga 61 l'indirizzo preimpostato <span class="address">0x3D</span> con <span class="address">0x3C</span>:</p>
<pre class="code">
[file ssd1306_128x64_i2c.ino]

...

void setup()   {
  Serial.begin(9600);

  // by default, we'll generate the high voltage from the 3.3v line internally!
  display.begin(SSD1306_SWITCHCAPVCC, <del>0x3D</del><ins>0x3C</ins>);  // initialize with the I2C...
  // init done

  // Show image buffer on the display hardware.
  // Since the buffer is intialized with an Adafruit splashscreen
  // internally, this will display the splashscreen.
  display.display();
  delay(2000);

  ...
}
</pre>
<p>Avviata la compilazione, ho ottenuto il seguente errore:</p>
<pre class="code">
Height incorrect, please fix Adafruit_SSD1306.h!
</pre>
<p>Il problema nasce dal fatto che la libreria <span class="library">Adafruit SSD1306</span> è predisposta per pilotare un display con una risoluzione di 128x32 pixel, mentre quello in uso ha un'altezza doppia. Per indicare alla libreria l'effettiva risoluzione del display è necessario modificare una dichiarazione all'interno del file <span class="path">Adafruit_SSD1306.h</span> che si trova nella cartella <span class="path">Arduino/libraries/Adafruit_SSD1306</span> all'interno della cartella <span class="term">home</span> dell'utente corrente. L'intervento va effettuato alla riga 73:</p>
<pre class="code">
//   #define SSD1306_128_64
   #define SSD1306_128_32
//   #define SSD1306_96_16
</pre>
<p class="illustration">Il codice originale della libreria</p>
<pre class="code">
   #define SSD1306_128_64
//   #define SSD1306_128_32
//   #define SSD1306_96_16
</pre>
<p class="illustration">Il codice modificato con la risoluzione corretta selezionata</p>
<p>Il codice ora compila e una volta trasferito sulla scheda Arduino permette di apprezzare le caratteristiche grafiche del display a disposizione.</p>
<h2>Sketch</h2>
<p>Lo sviluppo dello sketch per il display OLED inizia da quello per display LCD, dopo aver eliminato il codice relativo al display LCD e all'acquisizione dell'accelerazione sull'asse z, in questo caso superflua:</p>
<pre class="code">
<del>#include &lt;LiquidCrystal.h&gt;</del>
#include &lt;Wire.h&gt;

const int8_t MPU_I2C_ADDR = 0x68; // address of the MPU-6050 device

const int8_t XG_OFFS_USRH = 0x06; // Accelerometer Offset Cancellation
const int8_t ACCEL_CONFIG = 0x1C; // Accelerometer Configuration
const int8_t ACCEL_XOUT_H = 0x3B; // Accelerometer Measurements
const int8_t PWR_MGMT_1   = 0x6B; // Power Management 1 register address

// accelerometer full scale modes
const int8_t AFS_SEL_2G   = 0x00;
const int8_t AFS_SEL_4G   = 0x08;
const int8_t AFS_SEL_8G   = 0x10;
const int8_t AFS_SEL_16G  = 0x18;

<del>float to_g_force;</del>

<del>// declare the LCD wiring schema used</del>
<del>LiquidCrystal lcd(12, 11, 5, 4, 3, 2);</del>
const int display_refresh_rate_ms = 500;     // update the display every 500ms
unsigned long last_display_refresh_time = 0; // last time the display was updated

<del>// define the masks for the two rows</del>
<del>static char* upper_row = &quot;X:       Y:     &quot;;</del>
<del>static char* lower_row = &quot;Z:       A:     &quot;;</del>

// data acquisition rate
const unsigned long scan_rate_ms = 10;       // sample at 100Hz

// data buffers
const int buffer_length = 100;

<del>float</del><ins>int16_t</ins> accel_x_buffer[buffer_length];
<del>float</del><ins>int16_t</ins> accel_y_buffer[buffer_length];
<del>float accel_z_buffer[buffer_length];</del>
float accel_a_buffer[buffer_length];

int next_scan_index = 0;                     // where the next sample will be saved

<del>void sprintf_accel(char* buffer, int pos, float value) {
  // convert the floating point value in cents
  int cents = static_cast&lt;int&gt;(value * 100);
  // print the sign
  if (cents &gt;= 0)
    buffer[pos++] = &apos;+&apos;;
  else
    buffer[pos++] = &apos;-&apos;;
  // print the value, or 9.99 if it is too big
  cents = min(999, labs(cents));
  buffer[pos++] = &apos;0&apos; + cents / 100 % 10; // units
  buffer[pos++] = &apos;.&apos;;                    // decimal separator
  buffer[pos++] = &apos;0&apos; + cents /  10 % 10; // tenths
  buffer[pos++] = &apos;0&apos; + cents       % 10; // cents
}</del>

void setup() {
  // initialize the Wire library
  Wire.begin();

  // wake up the mpu-6050 unit
  Wire.beginTransmission(MPU_I2C_ADDR);
  Wire.write(PWR_MGMT_1);
  Wire.write(0);
  Wire.endTransmission();

  // select the accelerometer full scale
  int8_t afs_sel = AFS_SEL_2G;

  // set the accelerometer full scale
  Wire.beginTransmission(MPU_I2C_ADDR);
  Wire.write(ACCEL_CONFIG);
  Wire.write(afs_sel);
  Wire.endTransmission();

<del>  // set the acceleration conversion factor
  to_g_force = 1. / (16384 &gt;&gt; (afs_sel &gt;&gt; 3 &amp; 0x03));</del>

  // calibrate the accelerometer
  const int16_t offset_x = -2574;
  const int16_t offset_y =   336;
  const int16_t offset_z =  1755;
  Wire.beginTransmission(MPU_I2C_ADDR);
  Wire.write(XG_OFFS_USRH);

  uint8_t offsets[6];
  offsets[0] = static_cast&lt;uint8_t&gt;(offset_x &gt;&gt; 8);
  offsets[1] = static_cast&lt;uint8_t&gt;(offset_x &amp; 0x00ff);
  offsets[2] = static_cast&lt;uint8_t&gt;(offset_y &gt;&gt; 8);
  offsets[3] = static_cast&lt;uint8_t&gt;(offset_y &amp; 0x00ff);
  offsets[4] = static_cast&lt;uint8_t&gt;(offset_z &gt;&gt; 8);
  offsets[5] = static_cast&lt;uint8_t&gt;(offset_z &amp; 0x00ff);

  Wire.write(offsets, 6);
  Wire.endTransmission();

<del>  // initialize the LCD display
  lcd.begin(16, 2);</del>

<del>  // print the first row template
  lcd.setCursor(0, 0);
  lcd.print(upper_row);</del>

<del>  // print the second row template
  lcd.setCursor(0, 1);
  lcd.print(lower_row);</del>
}

void loop() {
  unsigned long loop_start = millis();

  // point to the first accelerometer register
  Wire.beginTransmission(MPU_I2C_ADDR);
  Wire.write(ACCEL_XOUT_H);
  Wire.endTransmission();

  // read <del>six</del><ins>four</ins> bytes of data
  Wire.requestFrom(MPU_I2C_ADDR, <del>6</del><ins>4</ins>);

  // the most significant byte is transmitted first!
  int16_t accel_x = Wire.read() &lt;&lt; 8 | Wire.read();
  int16_t accel_y = Wire.read() &lt;&lt; 8 | Wire.read();
  int16_t accel_z = Wire.read() &lt;&lt; 8 | Wire.read();

<del>  // convert the accelerometer readings to g-force values
  float accel_x_g = accel_x * to_g_force;
  float accel_y_g = accel_y * to_g_force;
  float accel_z_g = accel_z * to_g_force;</del>

  // calculate the total acceleration
<del>  float accel_a_g = sqrt(
    accel_x_g * accel_x_g
    + accel_y_g * accel_y_g
    + accel_z_g * accel_z_g</del>);
<ins>  float accel_a = sq(accel_x) + sq(accel_y);</ins>

  // save the acceleration data
  accel_x_buffer[next_scan_index] = accel_x<del>_g</del>;
  accel_y_buffer[next_scan_index] = accel_y<del>_g</del>;
<del>  accel_z_buffer[next_scan_index] = accel_z_g;</del>
  accel_a_buffer[next_scan_index] = accel_a<del>_g</del>;

  // find the position for the next scan
  next_scan_index = (next_scan_index + 1) % buffer_length;

  // time to update the display?
  if (millis() - last_display_refresh_time &gt; display_refresh_rate_ms) {
    // time to update the display
    last_display_refresh_time = millis();

    // find the maximum acceleration index
    int max_scan_index = 0;

    for (int i = 1; i &lt; buffer_length; i++)
      if (accel_a_buffer[i] &gt; accel_a_buffer[max_scan_index])
        max_scan_index = i;

<del>    // print the acceleration values into the row templates
    sprintf_accel(upper_row,  2, accel_x_buffer[max_scan_index]);
    sprintf_accel(upper_row, 11, accel_y_buffer[max_scan_index]);
    sprintf_accel(lower_row,  2, accel_z_buffer[max_scan_index]);
    sprintf_accel(lower_row, 11, accel_a_buffer[max_scan_index]);</del>

<del>    // update the display
    lcd.setCursor(0, 0);
    lcd.print(upper_row);
    lcd.setCursor(0, 1);
    lcd.print(lower_row);</del>
  }

  // wait for the acquisition period to expire
  unsigned long elapsed = millis() - loop_start;

  if (elapsed &lt; scan_rate_ms)
    delay(scan_rate_ms - elapsed);
}
</pre>
<p>Oltre a quanto anticipato, considerato che non è richiesta la visualizzazione dei valori di accelerazione espressi in frazioni di g, si è optato per lavorare con i dati grezzi acquisiti dal sensore, in modo da evitare inutili operazioni in virgola mobile che sono particolarmente onerose per il microcontrollore montato sulla scheda Arduino &mdash; fino a 10 volte più lente rispetto alle operazioni sui numeri interi<a href="#ref-4"><sup>[4]</sup></a><a href="#ref-5"><sup>[5]</sup></a><a href="#ref-6"><sup>[6]</sup></a><a href="#ref-8"><sup>[8]</sup></a>. La variabile <span class="code">accel_a</span> (che contiene ora il quadrato del valore di accelerazione totale) rimane <span class="code">float</span> per evitare condizioni di <span class="term">overflow</span>, quando cioè il dato grezzo è così elevato che il suo quadrato non è rappresentabile con soli 16 bit.</p>
<p>Perché non si calcola il valore effettivo di accelerazione ma &ldquo;solo&rdquo; il suo quadrato? Poiché questo valore viene usato solo per determinare il campione massimo, calcolarne la radice quadrata sarebbe un inutile spreco di tempo: il massimo dei quadrati è anche il massimo dei valori sotto radice.</p>
<p>Lo sketch ora acquisisce i dati, ma non li visualizza. Considerando che la risoluzione del display è di 128x64 pixel, conviene mostrare il diagramma cartesiano in prospettiva, in forma di ovale:</p>
<img src="img/arduino-mpu6050-oled/grid.png">
<p class="illustration">Il piano grafico visto in prospettiva</p>
<p>La griglia vuole essere un omaggio a <a href="https://it.wikipedia.org/wiki/Elite_(videogioco)">Elite</a>, cui giocavo negli anni '80:</p>
<img src="img/arduino-mpu6050-oled/elite.png">
<p class="illustration">La schermata iniziale di Elite sullo ZX Spectrum</p>
<p>I valori di accelerazione lungo gli assi x e y saranno rappresentati da un punto fluttuante sulla superficie del grafico. Considerando il posizionamento dei due sensori ed i sistemi di riferimento da essi adottati, l'asse x dell'accelerometro corrisponde alle ordinate del display, mentre l'asse y dell'accelerometro a quello delle ascisse:</p>
<img src="img/arduino-mpu6050-oled/axes.jpg">
<p class="illustration">Corrispondenza tra i sistemi di riferimento sensore/display</p>
<p>Definita la modalità di visualizzazione, si dichiara e inizializza il display:</p>
<pre class="code">
<ins>#include &lt;SPI.h&gt;</ins>
#include &lt;Wire.h&gt;
<ins>#include &lt;Adafruit_GFX.h&gt;</ins>
<ins>#include &lt;Adafruit_SSD1306.h&gt;</ins>
...

<ins>// declare the OLED display used
#define OLED_RESET 4
Adafruit_SSD1306 display(OLED_RESET);</ins>
const int display_refresh_rate_ms = <del>500</del><ins>100</ins>;     // update the display every <del>500</del><ins>100</ins>ms
unsigned long last_display_refresh_time = 0; // last time the display was updated
...

// data acquisition rate
const unsigned long scan_rate_ms = <del>10</del><ins>5</ins>;       // sample at <del>100</del><ins>200</ins>Hz

// data buffers
const int buffer_length = <del>100</del><ins>20</ins>;
...

void setup() {
  ...

<ins>  // initialize the display
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);</ins>

<ins>  // hide the Adafruit welcome screen
  display.clearDisplay();
  display.display();</ins>
}
</pre>
<p>L'uso delle librerie grafiche richiede un discreto quantitativo di memoria, tant'è che se si lascia a 100 la dimensione del buffer dove vengono temporaneamente conservati i dati grezzi ottenuti dal sensore la compilazione dello sketch fallisce con errore &laquo;<span class="code">not enough memory</span>&raquo;. Conviene perciò diminuire a 20 il numero di campioni memorizzati. Considerando d'altra parte che i tempi di risposta del display OLED sono molto più rapidi di un LCD, si può aumentare la frequenza di campionamento a 200Hz. I 20 campioni acquisiti a 200Hz coprono un intervallo di tempo di 100ms, e questa sarà la durata del ciclo di aggiornamento del display: in questo modo il display verrà aggiornato al completo ricaricamento del buffer.</p>
<p>Per semplicità, il ciclo di aggiornamento del display consiste in una cancellazione, seguita dal caricamento dell'immagine della griglia e dal disegno del cursore nella posizione corrispondente ai valori di accelerazione. Ripristinare solo la parte di griglia al di sotto del cursore potrebbe risultare più efficiente rispetto al ridisegno dell'intero schermo ma, consideratane la complessità, l'aggiornamento mirato del display verrà implementato solo se necessario:</p>
<pre class="code">
void loop() {
  ...

  // time to update the display?
  if (millis() - last_display_refresh_time &gt; display_refresh_rate_ms) {
    // time to update the display
    last_display_refresh_time = millis();

    // find the maximum acceleration index
    int max_scan_index = 0;

    for (int i = 1; i &lt; buffer_length; i++)
      if (accel_a_buffer[i] &gt; accel_a_buffer[max_scan_index])
        max_scan_index = i;

<ins>    // clear the drawing area
    display.clearDisplay();</ins>

<ins>    // load the grid image
    display.drawBitmap(
      (display.width()  - grid_width ) / 2, // x
      (display.height() - grid_height) / 2, // y
      grid_bitmap,
      grid_width,
      grid_height,
      WHITE);</ins>

<ins>    // plot the cursor
    display.fillCircle(
      display.width()  / 2 - (accel_y_buffer[max_scan_index] &gt;&gt;  9),
      display.height() / 2 - (accel_x_buffer[max_scan_index] &gt;&gt; 10),
      cursor_radius,
      WHITE);</ins>

<ins>    // refresh the display
    display.display();</ins>
  }

  // wait for the acquisition period to expire
  unsigned long elapsed = millis() - loop_start;

  if (elapsed &lt; scan_rate_ms)
    delay(scan_rate_ms - elapsed);
}
</pre>
<p>Si può notare che l'immagine della griglia viene centrata sul display. La definizione della <span class="term">bitmap</span> monocromatica della griglia consiste di 42 righe di 14 byte ciascuna (14 &times; 8 = 112 colonne), ed è la seguente:</p>
<pre class="code">
// the grid
static const int grid_width  = 112;
static const int grid_height =  42;

static const unsigned char PROGMEM grid_bitmap[] = {
  B00000000, B00000000, B00000000, B00000000, B00000000, B00000101, B01010101,
   B01010101, B01010000, B00000000, B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000, B00000001, B01010000, B00000000,
   B00000000, B00000101, B01000000, B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000, B01011100, B00000000, B00000001,
   B00000000, B00000000, B00011010, B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00001111, B00001000, B00000000, B00000000,
   B00000000, B00000000, B00010000, B11110000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B11100000, B00000000, B00000000, B00000000,
   B10000000, B00000000, B00000000, B00000111, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000110, B00000000, B00100000, B00000000, B00000000,
   B00000000, B00000000, B00000100, B00000000, B01100000, B00000000, B00000000,
  B00000000, B00000000, B00110000, B00000000, B00000000, B00000000, B00000001,
   B00000000, B00000000, B00000000, B00000000, B00001100, B00000000, B00000000,
  B00000000, B00000000, B10000000, B00000000, B10000000, B00000000, B00000000,
   B00000000, B00000000, B00000001, B00000000, B00000001, B00000000, B00000000,
  B00000000, B00000010, B00000000, B00000000, B00000000, B00000000, B00000000,
   B10000000, B00000000, B00000000, B00000000, B00000000, B01000000, B00000000,
  B00000000, B00001000, B00000000, B00000010, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B01000000, B00000000, B00010000, B00000000,
  B00000000, B00100010, B00100010, B00100000, B01000100, B01000100, B01000101,
   B00100010, B00100010, B00100010, B00000100, B01000100, B01000100, B00000000,
  B00000000, B10000000, B00000000, B00001000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00010000, B00000000, B00000001, B00000000,
  B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
   B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
  B00000010, B00000000, B00000000, B00100000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000100, B00000000, B00000000, B01000000,
  B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001,
   B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
  B00001000, B00000000, B00000000, B10000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000001, B00000000, B00000000, B00010000,
  B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
   B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
  B00010000, B00000000, B00000010, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B01000000, B00000000, B00001000,
  B00100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001,
   B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000100,
  B00100000, B00000000, B00001000, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00010000, B00000000, B00000100,
  B00110001, B00010001, B00000001, B00010001, B00010001, B00010001, B00010000,
   B10001000, B10001000, B10001000, B10001000, B10000001, B00010001, B00010100,
  B00100000, B00000000, B00100000, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00000100, B00000000, B00000100,
  B00100000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001,
   B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000100,
  B00010000, B00000000, B10000000, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00000001, B00000000, B00001000,
  B00010000, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
   B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00001000,
  B00001000, B00000010, B00000000, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00000000, B01000000, B00010000,
  B00000100, B00000000, B00000000, B00000000, B00000000, B00000000, B00000001,
   B00000000, B00000000, B00000000, B00000000, B00000000, B00000000, B00100000,
  B00000010, B00001000, B00000000, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00000000, B00010000, B01000000,
  B00000001, B00000000, B00000000, B00000000, B00000000, B00000000, B00000000,
   B10000000, B00000000, B00000000, B00000000, B00000000, B00000000, B10000000,
  B00000000, B10100000, B00000000, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00000000, B00000101, B00000000,
  B00000000, B01101000, B10001000, B10001000, B10001000, B10001000, B10001001,
   B00010001, B00010001, B00010001, B00010001, B00010001, B00010110, B00000000,
  B00000000, B00001000, B00000000, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00000000, B00011000, B00000000,
  B00000000, B00000110, B00000000, B00000000, B00000000, B00000000, B00000000,
   B10000000, B00000000, B00000000, B00000000, B00000000, B01100000, B00000000,
  B00000000, B00000001, B10000000, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00000001, B10000000, B00000000,
  B00000000, B00000000, B01100000, B00000000, B00000000, B00000000, B00000001,
   B00000000, B00000000, B00000000, B00000000, B00000110, B00000000, B00000000,
  B00000000, B00000000, B00011100, B00000000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00000000, B00111000, B00000000, B00000000,
  B00000000, B00000000, B00000011, B10000000, B00000000, B00000000, B00000000,
   B10000000, B00000000, B00000000, B00000001, B11000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B01110000, B00000000, B00000000, B00000000,
   B00000000, B00000000, B00000000, B00001110, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00001111, B00000000, B00000000, B00000001,
   B00000000, B00000000, B00000000, B11110000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000, B11111000, B00000000, B00000000,
   B00000000, B00000000, B00011111, B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000, B00000111, B11111000, B00000000,
   B10000000, B00011111, B11100000, B00000000, B00000000, B00000000, B00000000,
  B00000000, B00000000, B00000000, B00000000, B00000000, B00000111, B11111111,
   B11111111, B11100000, B00000000, B00000000, B00000000, B00000000, B00000000,
};
</pre>
<p>Il cursore è rappresentato da un cerchio pieno, di raggio prefissato:</p>
<pre class="code">
<ins>// the cursor
static const int cursor_radius = 4;</ins>

// the grid
static const int grid_width  = 112;
static const int grid_height =  42;
...
</pre>
<p>La posizione del cursore è determinata con un metodo piuttosto efficiente, anche se impreciso (comunque accettabile per questo tipo di implementazione). La prima considerazione è che i valori di accelerazione acquisiti dal sensore sono interi a 16 bit con segno. La seconda è che per le accelerazioni trasversali (asse y dell'accelerometro, corrispondente alle ascisse del display), le coordinate assunte dal cursore vanno da 0 a 127, mentre per quelle longitudinali (asse x dell'accelerometro, corrispondente alle ordinate del display) vanno da 0 a 63. Per mappare un valore a 16 bit con segno nell'intervallo [0..127] è sufficiente ridurlo nell'intervallo [-64..+63] con una semplice operazione di shift di 9 posizioni, e aggiungere 64 al risultato. Idem per la mappatura sull'intervallo [0..63], con l'accortezza di effettuare uno shift del dato grezzo di 10 posizioni per ridurlo nell'intervallo [-32..+31], e sommare 32 al risultato ottenuto.</p>
<p>Notare che su entrambe le coordinate è stato effettuato un cambiamento di segno, in modo che il movimento del cursore sul diagramma rispecchi le accelerazioni effettivamente misurate dal sensore.</p>
<img src="img/arduino-mpu6050-oled/grid-oled.jpg">
<p class="illustration">Il display OLED in funzione</p>
<p>La versione dello sketch fin qui ottenuta è scaricabile <a href="files/arduino-mpu6050-oled/basic/mpu6050-oled.ino">qui</a>.</p>
<h2>Cambio scala manuale</h2>
<p>Poiché il sensore può funzionare con quattro sensibilità differenti, si può estendere il circuito e il firmware per consentire all'utente di selezionare il fondo scala che preferisce?</p>
<p>Per impratichirmi con l'uso delle <span class="term">interrupt</span>, ho deciso di comandare il fondo scala con un'interruzione: la pressione di un pulsante genera un'interrupt che si occupa di configurare il sensore sul fondo scala successivo, secondo il ciclo &plusmn;2g &rarr; &plusmn;4g &rarr; &plusmn;8g &rarr; &plusmn;16g &rarr; &plusmn;2g &hellip;</p>
<p>Sfruttando la possibilità che offre la scheda Arduino di generare un'interruzione in corrispondenza di un cambiamento del livello elettrico presente sul pin <span class="pin">3</span>, il circuito si arricchisce di un pulsante che collega il suddetto pin a massa:</p>
<img src="img/arduino-mpu6050-oled/wiring-mpu5060-display-button.png">
<p class="illustration">Il pulsante per il cambio scala</p>
<img src="img/arduino-mpu6050-oled/circuit-mpu5060-display-button.jpg">
<p class="illustration">Dettaglio del pulsante di cambio scala</p>
<p>A livello software c'è da tener conto di una particolarità della piattaforma Arduino: durante il servizio di un'interruzione non è possibile utilizzare la libreria <span class="library">Wire</span> perché lei stessa ne fa uso<a href="#ref-7"><sup>[7]</sup></a><a href="#ref-9"><sup>[9]</sup></a>. Nella <span class="term">routine</span> di gestione dell'interruzione non si può quindi inviare il comando di cambio fondo scala al sensore, ma si può richiedere al programma principale di farlo quanto prima. A tal scopo si usano due variabili, <span class="code">afs_sel</span> che indica il fondo scala corrente e <span class="code">new_afs_sel</span> che indica invece il fondo scala desiderato: se i due valori sono diversi, il programma principale invia il comando di cambio fondo scala. La routine di gestione dell'interrupt si limita quindi ad aggiornare il valore della variabile <span class="code">new_afs_sel</span>, lasciando che sia il programma principale ad inoltrare la richiesta al sensore.</p>
<p>Lo sketch va esteso per supportare la nuova funzionalità, che prevede anche la visualizzazione del fondo scala corrente nell'angolo in basso a sinistra del display:</p>
<pre class="code">
...

// accelerometer full scale modes
const int8_t AFS_SEL_2G   = 0x00;
const int8_t AFS_SEL_4G   = 0x08;
const int8_t AFS_SEL_8G   = 0x10;
const int8_t AFS_SEL_16G  = 0x18;

<ins>volatile int8_t afs_sel;
volatile int8_t new_afs_sel;</ins>
...

<ins>// interrupt handler
void changeScale() {
  if (afs_sel == AFS_SEL_2G)
    new_afs_sel = AFS_SEL_4G;
  else if (afs_sel == AFS_SEL_4G)
    new_afs_sel = AFS_SEL_8G;
  else if (afs_sel == AFS_SEL_8G)
    new_afs_sel = AFS_SEL_16G;
  else if (afs_sel == AFS_SEL_16G)
    new_afs_sel = AFS_SEL_2G;
}</ins>

void setup() {
  // initialize the Wire library
  Wire.begin();

  // wake up the mpu-6050 unit
  Wire.beginTransmission(MPU_I2C_ADDR);
  Wire.write(PWR_MGMT_1);
  Wire.write(0);
  Wire.endTransmission();

  // select the accelerometer full scale
  <del>int8_t</del> afs_sel = AFS_SEL_2G;
  <ins>new_afs_sel = afs_sel;</ins>
  ...

  // hide the Adafruit welcome screen
  display.clearDisplay();
  display.display();

<ins>  // attach the interrupt handler
  const byte changeScalePin = 3;
  pinMode(changeScalePin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(changeScalePin), changeScale, FALLING);</ins>
}

void loop() {
  unsigned long loop_start = millis();

<ins>  // change the accelerometer scale if requested
  if (new_afs_sel != afs_sel) {
    afs_sel = new_afs_sel;
    // set the accelerometer full scale
    Wire.beginTransmission(MPU_I2C_ADDR);
    Wire.write(ACCEL_CONFIG);
    Wire.write(afs_sel);
    Wire.endTransmission();
  }</ins>
  ...

  // time to update the display?
  if (millis() - last_display_refresh_time &gt; display_refresh_rate_ms) {
    ...

    // load the grid image
    display.drawBitmap(
      (display.width()  - grid_width ) / 2, // x
      (display.height() - grid_height) / 2, // y
      grid_bitmap,
      grid_width,
      grid_height,
      WHITE);

<ins>    // print the current accelerometer scale
    display.setCursor(0, display.height() - 8);
    display.setTextColor(WHITE);
    display.print(&quot;FS=&quot;);
    display.print(2 &lt;&lt; ((afs_sel &gt;&gt; 3) &amp; 0x03));
    display.print(&quot;g&quot;);</ins>

    // plot the cursor
    display.fillCircle(
      display.width()  / 2 - (accel_y_buffer[max_scan_index] &gt;&gt;  9),
      display.height() / 2 - (accel_x_buffer[max_scan_index] &gt;&gt; 10),
      cursor_radius,
      WHITE);
  }
  ...
}
</pre>
<p>Da notare la manipolazione binaria della variabile <span class="code">afs_sel</span> per passare dalle costanti <span class="code">AFS_SEL_*G</span> all'effettivo valore del fondo scala 2, 4, 8 o 16.</p>
<img src="img/arduino-mpu6050-oled/grid-oled-fs.jpg">
<p class="illustration">Il display OLED con l'indicazione del fondo scala</p>
<p>La versione dello sketch con la gestione del fondo scala è scaricabile <a href="files/arduino-mpu6050-oled/scale-change/mpu6050-oled.ino">qui</a>.</p>
<h2>Estensioni</h2>
<p>Segue un elenco non esaustivo di possibili sviluppi del progetto:</p>
<ul>
<li>aumentare la precisione della rappresentazione grafica rimodulando la posizione del cursore in funzione delle dimensioni effettive della griglia;</li>
<li>aggiungere la scala fittizia &plusmn;1g utilizzando la scala &plusmn;2g del sensore e diminuendo di un'unità lo shift verso destra dei dati grezzi;</li>
<li>mostrare il valore di accelerazione attuale;</li>
<li>mostrare i valori massimi di accelerazione nelle quattro direzioni principali ai lati del grafico;</li>
<li>aggiungere l'indicazione dell'accelerazione sull'asse z con una barra verticale a lato del grafico polare;</li>
<li>mostrare la traccia del cursore sul grafico polare;</li>
<li>commutare automaticamente alla scala superiore al superamento del fondo scala corrente;</li>
<li>aggiungere una schermata iniziale di benvenuto;</li>
<li>&hellip;</li>
</ul>
<p class="update"><strong>Aggiornamento [06/01/2016]</strong></p>
<h3>Aggiunta della scala &plusmn;1g</h3>
<p>Avendo messo alla prova l'accelerometro durante alcuni brevi viaggi in auto, ho potuto constatare che la scala &plusmn;2g ha una sensibilità troppo limitata per le accelerazioni che si sperimentano su un'auto convenzionale: il cursore rimane sempre nei pressi del centro del grafico. Ho pensato quindi di modificare lo sketch introducendo la scala fittizia &plusmn;1g impostando l'accelerometro sulla scala minima &plusmn;2g e riducendo di un fattore 2 la rimappatura dei valori di accelerazione. A tal scopo è stata introdotta una variabile booleana che indica se ci si trova nella scala &plusmn;1g o &plusmn;2g:</p>
<pre class="code">
volatile int8_t afs_sel;
volatile int8_t new_afs_sel;
<ins>volatile bool emulate_1g_afs;</ins>
...

void setup() {
  ...

  // select the accelerometer full scale
  afs_sel = AFS_SEL_2G;
  new_afs_sel = afs_sel;

<ins>  // start with the fake 1g scale
  emulate_1g_afs = true;</ins>
  ...
}
</pre>
<p>Nella routine di cambio scala bisogna ora tener conto della nuova sensibilità:</p>
<pre class="code">
// interrupt handler
void changeScale() {
  if (afs_sel == AFS_SEL_2G) <ins>{
    if (emulate_1g_afs == true)
      emulate_1g_afs = false; // switch from fake 1g to actual 2g scale
    else</ins>
      new_afs_sel = AFS_SEL_4G;
  <ins>}</ins>
  else if (afs_sel == AFS_SEL_4G)
    new_afs_sel = AFS_SEL_8G;
  else if (afs_sel == AFS_SEL_8G)
    new_afs_sel = AFS_SEL_16G;
  else if (afs_sel == AFS_SEL_16G) <ins>{</ins>
    new_afs_sel = AFS_SEL_2G;
<ins>    emulate_1g_afs = true; // back to fake 1g scale
  }</ins>
}
</pre>
<p>La tabella sottostante riporta la mappatura tra la scala selezionata dall'utente, i valori assunti delle variabili <span class="code">afs_sel</span> e <span class="code">emulate_1g_afs</span> e l'entità dello shift applicato ai valori di accelerazione sui due assi del display:</p>
<table cellpadding="0" cellspacing="0">
<tr><th>scala</th><th><span class="code">afs_sel</span></th><th><span class="code">emulate_1g_afs</span></th><th>shift x</th><th>shift y</th></tr>
<tr><td>&plusmn;1g</td><td>AFS_SEL_2G</td><td>true</td><td>8</td><td>9</td></tr>
<tr><td>&plusmn;2g</td><td>AFS_SEL_2G</td><td>false</td><td>9</td><td>10</td></tr>
<tr><td>&plusmn;4g</td><td>AFS_SEL_4G</td><td>false</td><td>9</td><td>10</td></tr>
<tr><td>&plusmn;8g</td><td>AFS_SEL_8G</td><td>false</td><td>9</td><td>10</td></tr>
<tr><td>&plusmn;16g</td><td>AFS_SEL_16G</td><td>false</td><td>9</td><td>10</td></tr>
</table>
<p>Resta solo da visualizzare la nuova scala ed applicare lo shift corretto:</p>
<pre class="code">
void loop() {
  ...

  // time to update the display?
  if (millis() - last_display_refresh_time &gt; display_refresh_rate_ms) {
    ...

    // print the current accelerometer scale
    display.setCursor(0, display.height() - 8);
    display.setTextColor(WHITE);
    display.print(&quot;FS=&quot;);
    <ins>if (emulate_1g_afs)
        display.print(1);
    else</ins>
      display.print(2 &lt;&lt; ((afs_sel &gt;&gt; 3) &amp; 0x03));
    display.print(&quot;g&quot;);

    // plot the cursor
    display.fillCircle(
      <del>display.width()  / 2</del>
      <ins>64</ins> - (accel_y_buffer[max_scan_index] &gt;&gt; <ins>(emulate_1g_afs ? 8 :</ins>  9<ins>)</ins>),
      <del>display.height() / 2</del>
      <ins>32</ins> - (accel_x_buffer[max_scan_index] &gt;&gt; <ins>(emulate_1g_afs ? 9 :</ins> 10<ins>)</ins>),
      cursor_radius,
      WHITE);

    // refresh the display
    display.display();
  }
  ...

}
</pre>
<p>La versione dello sketch con la scala fittizia &plusmn;1g è scaricabile da <a href="files/arduino-mpu6050-oled/1g/mpu6050-oled.ino">qui</a>.</p>
<h3>Aumento della precisione</h3>
<p>Con l'aumento della sensibilità, diventa più evidente l'approssimazione introdotta nella mappatura dei valori di accelerazione sul grafico:</p>
<img src="img/arduino-mpu6050-oled/mapping-error.jpg">
<p class="illustration">Posizione del cursore a fronte di un'accelerazione trasversale di 1g</p>
<p>Come già detto, l'errore è dovuto al fatto che la scala dei valori di accelerazione trasversale viene mappata sulla larghezza del display (128 pixel) sebbene l'asse maggiore dell'ellisse sia lungo solo 108 pixel; stesso discorso per le accelerazioni longitudinali, i cui valori sono mappati sull'intera altezza del display (64 pixel) quando in realtà l'asse minore dell'ellisse ne misura solo 42.</p>
<p>Si può aumentare l'accuratezza della mappatura senza ricorrere all'uso della matematica in virgola mobile con un semplice stratagemma. Consideriamo ad esempio il semiasse positivo delle ascisse, sul quale vengono mappati i valori di accelerazione trasversale destra:</p>
<p class="formula">accel_y &rarr; x &isin; [0, 64)</p>
<p>Questi valori dovrebbero in realtà essere mappati sulla lunghezza del semiasse orizzontale dell'ellisse:</p>
<p class="formula">accel_y &rarr; x &isin; [0, 56)</p>
<p>Dunque le coordinate x andrebbero normalizzate di un fattore:</p>
<p class="formula">x' = x &middot; 56 / 64 = x &middot; 0,875</p>
<p>La formula può essere così riscritta:</p>
<p class="formula">x' = x &middot; 0,875 = x &middot; (1 - 0,125) = x - x &middot; 0,125 = x - x / 8</p>
<p>Essendo x intera, anche la divisione è tra numeri interi. Similmente si procede per le ordinate:</p>
<p class="formula">accel_x &rarr; y &isin; [0, 32) &mdash; mappatura attuale</p>
<p class="formula">accel_x &rarr; y &isin; [0, 21) &mdash; mappatura desiderata</p>
<p class="formula">y' = y &middot; 21 / 32 = y &middot; 0,65625</p>
<p class="formula">y' = y &middot; 0,65625 = y &middot; (1 - 0,34375) = y - y &middot; 0,34375 &cong; y - y / 3</p>
<p>L'espressione intera in questo caso è un'approssimazione della mappatura ottimale, ma un'appossimazione nettamente migliore alla precedente. Il codice diventa:</p>
<pre class="code">
void loop() {
  ...
  // time to update the display?
  if (millis() - last_display_refresh_time &gt; display_refresh_rate_ms) {
    ...

    // plot the cursor
    <ins>int32_t x = accel_y_buffer[max_scan_index] &gt;&gt; (emulate_1g_afs ? 8 :  9);
    int32_t y = accel_x_buffer[max_scan_index] &gt;&gt; (emulate_1g_afs ? 9 : 10);</ins>

    display.fillCircle(
      64 - <del>(accel_y_buffer[max_scan_index] &gt;&gt; (emulate_1g_afs ? 8 :  9))</del><ins>(x - x / 8)</ins>,
      32 - <del>(accel_x_buffer[max_scan_index] &gt;&gt; (emulate_1g_afs ? 9 : 10))</del><ins>(y - y / 3)</ins>,
      cursor_radius,
      WHITE);
    ...
  }
}
</pre>
<img src="img/arduino-mpu6050-oled/mapping-corrected.jpg">
<p class="illustration">Posizione del cursore corretta</p>
<p>La versione finale dello sketch è disponibile <a href="files/arduino-mpu6050-oled/corrected/mpu6050-oled.ino">qui</a>.</p>
<h2>Riferimenti</h2>
<ol>
<li class="ref"><a name="ref-1"></a><em>&ldquo;Adafruit GFX Graphics Library Guide&rdquo;</em>, learn.adafruit.com &mdash; <a href="https://learn.adafruit.com/adafruit-gfx-graphics-library/">https://learn.adafruit.com/adafruit-gfx-graphics-library/</a>, visitato il 30/12/2016.</li>
<li class="ref"><a name="ref-2"></a><em>&ldquo;Adafruit-GFX-Library&rdquo;</em>, adafruit repository on github.com &mdash; <a href="https://github.com/adafruit/Adafruit-GFX-Library">https://github.com/adafruit/Adafruit-GFX-Library</a>, visitato il 30/12/2016.</li>
<li class="ref"><a name="ref-3"></a><em>&ldquo;Adafruit_SSD1306&rdquo;</em>, adafruit repository on github.com &mdash; <a href="https://github.com/adafruit/Adafruit_SSD1306">https://github.com/adafruit/Adafruit_SSD1306</a>, visitato il 30/12/2016.</li>
<li class="ref"><a name="ref-4"></a><em>&ldquo;Avoiding float math to speed up arduino&rdquo;</em>, StackExchange &mdash; <a href="http://arduino.stackexchange.com/questions/23238/avoiding-float-math-to-speed-up-arduino">http://arduino.stackexchange.com/questions/23238/avoiding-float-math-to-speed-up-arduino</a>, visitato il 01/01/2017.</li>
<li class="ref"><a name="ref-5"></a><em>&ldquo;Faster code Fridays: Avoid floating point math&rdquo;</em>, EngBlaze &mdash; <a href="http://www.engblaze.com/faster-code-fridays-avoid-floating-point-math/">http://www.engblaze.com/faster-code-fridays-avoid-floating-point-math/</a>, visitato il 01/01/2017.</li>
<li class="ref"><a name="ref-6"></a><em>&ldquo;Faster code Fridays: Understand division and speed of operations&rdquo;</em>, EngBlaze &mdash; <a href="http://www.engblaze.com/faster-code-fridays-understand-division-and-speed-of-operations/">http://www.engblaze.com/faster-code-fridays-understand-division-and-speed-of-operations/</a>, visitato il 01/01/2017.</li>
<li class="ref"><a name="ref-7"></a><em>&ldquo;Hardware Interrupt and I2C interference - how to resolve&rdquo;</em>, Arduino Forums &mdash; <a href="http://forum.arduino.cc/index.php?topic=308019.0">http://forum.arduino.cc/index.php?topic=308019.0</a>, visitato il 02/01/2017.</li>
<li class="ref"><a name="ref-8"></a><em>&ldquo;Speed of floating point operations -- test results&rdquo;</em>, Arduino Forums &mdash; <a href="http://forum.arduino.cc/index.php?topic=40901.0">http://forum.arduino.cc/index.php?topic=40901.0</a>, visitato il 01/01/2017.</li>
<li class="ref"><a name="ref-9"></a><em>&ldquo;Wire communication during interrupt handling&rdquo;</em>, Arduino Forums &mdash; <a href="http://forum.arduino.cc/index.php?topic=254857.0">http://forum.arduino.cc/index.php?topic=254857.0</a>, visitato il 02/01/2017.</li>
</ol>
<p class="modification-notice">Pagina modificata il 01/01/2017</p>
</body>
</html>
