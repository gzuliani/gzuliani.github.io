<html>
<head>
<meta charset="UTF-8">
<title>Comunicazione seriale Arduino/Android via USB</title>
<link href="../css/main.css" rel="stylesheet" type="text/css"></link>
<link href="css/arduino-android-usb.css" rel="stylesheet" type="text/css"></link>
</head>
<body>
<p class="page-path"><a href="../index.html#arduino-android-usb">risorse</a> | comunicazione seriale arduino/android via usb</p>
<h1>Comunicazione seriale Arduino/Android via USB</h1>
<p class="disclaimer"><strong>Attenzione:</strong> ho posto la massima cura ed attenzione nel redigere questi appunti; declino tuttavia ogni responsabilità per eventuali imprecisioni, errori od omissioni, così come declino ogni responsabilità per eventuali danni a cose, proprietà o persone derivanti dall’uso di questi contenuti.</p>
<p>Vorrei portare su Android il programma per PC &ldquo;<a href="https://bitbucket.org/gzuliani/sps-hc20">Consolle</a>&rdquo; che ho sviluppato per il <a href="arduino-scoreboard">controllo di un tabellone segnapunti</a> per il quale qualche mese fa ho realizzato un circuito di interfaccia. Il programma al momento gira su un vetusto portatile e il suo uso risulta macchinoso perché il computer non è dotato di <em>touch screen</em>. Nella foga della partita non è facile centrare sempre il pulsante giusto, e l'illuminazione della zona dei refertisti in palestra non è ottimale. Poiché tutti gli <em>smart phone</em> e i <em>tablet</em> oggi in circolazione ne sono dotati, ho pensato di trasformare il programma Python in un'applicazione per Android. Prima di tutto devo però accertarmi di poter comunicare dal terminale con Arduino via seriale USB, perché il Bluetooth in questo caso non è un'opzione.</p>
<h2>Dispositivi USB On-The-Go (OTG)</h2>
<p>Il primo passo consiste nel procurarsi un dispositivo Android in grado di funzionare come <em>host</em> USB. Dei tre terminali in mio possesso, un tablet Samsung Galaxy Tab 2 10.1, uno smartphone Samsung J3 e un Huawey P8 Light, solo i primi due supportano tale modalità, nota come <a href="https://en.wikipedia.org/wiki/USB_On-The-Go">USB OTG</a>.</p>
<p>Per attivare la modalità OTG (nei dispositivi che la supportano!) è necessario utilizzare un apposito cavetto di connessione: l'impiego di questo particolare accessorio fa sì che il dispositivo Android commuti da <em>slave</em> a <em>master</em>.</p>
<p>Poiché il Samsung Galaxy Tab è sprovvisto di una presa USB standard, ho dovuto acquistare due cavetti OTG: uno standard per una presa USB micro, uno per il connettore proprietario del tablet:</p>
<img src="img/arduino-android-usb/connectors.jpg">
<p class="illustration">In alto il cavo OTG standard per il Samsung J3, sotto quello dedicato per il Galaxy Tab</p>
<p>Resta ora da verificare come si debba stabilire una comunicazione seriale con Arduino.</p>
<h2>Sketch Arduino</h2>
<p>Per verificare la comunicazione tra il terminale Android e Arduino ho caricato un programma di <em>echo</em> seriale che lavora a 57600 baud sulla scheda (<a href="files/arduino-android-usb/serial-echo.ino">qui</a> il sorgente):</p>
<pre class="code">
void setup() {
    Serial.begin(57600);
}

void loop() {
    while (Serial.available() > 0)
        Serial.print((char)Serial.read());
}
</pre>
<h2>Applicazione Android</h2>
<p>Il principale riferimento per lo sviluppo di applicazioni che comunicano attraverso la porta seriale USB è la sezione <a href="https://developer.android.com/guide/topics/connectivity/usb/host">USB host overview</a> della documentazione ufficiale; in rete si trovano poi vari progetti che coinvolgono espressamente Arduino (due esempi: <a href="https://www.digikey.com/en/maker/projects/aed1f8e3fa044264a4310c6b3b2a4364">How to Use Your Android to Communicate with Your Arduino</a>, <a href="https://www.theengineeringprojects.com/2015/10/usb-communication-between-android-and-arduino.html">USB Communication between Android and Arduino</a>). Molti di questi si basano su librerie di terze parti, in particolare <a href="https://github.com/felHR85/UsbSerial">UsbSerial</a> che, pur essendo particolarmente diffusa, è affetta da qualche problema, in particolare non supporta Android 5.1.1 Lollipop. Per avere il massimo grado di libertà e soprattutto farmi un'idea di come funziona l'API sottostante, ho deciso di sviluppare in autonomia il codice di comunicazione, traendo comunque ispirazione dai progetti <em>open</em> che hanno fatto la stessa scelta.</p>
<h3>Abilitazione della modalità USB Host</h3>
<p>Le funzionalità di accesso all'Host USB sono state introdotte nell'API 12; è indispensabile basare l'applicazione su un'API di pari livello o superiore. È inoltre necessario indicare nel file <span class="path">AndroidManifest.xml</span> che l'applicazione richiede l'accesso a tale componente aggiunendo la riga evidenziata:</p>
<pre class="code">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.theengineeringprojects.dani&quot; &gt;

    <ins>&lt;uses-feature android:name=&quot;android.hardware.usb.host&quot; /&gt;</ins>

    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        ...

&lt;/manifest&gt;
</pre>
<h3>Identificazione della scheda Arduino</h3>
<p>Per poter comunicare con Arduino è necessario individuare l'oggetto software (istanza della classe <span class="code">android.hardware.usb.UsbDevice</span>) che lo rappresenta. Esistono due modi per farlo: registrarsi e attendere una notifica dal sistema operativo dell'avvenuto collegamento della scheda alla presa USB oppure effettuando una scansione manuale. Il primo è il più semplice, e richiede un secondo intervento nel file <span class="path">AndroidManifest.xml</span>:</p>
<pre class="code">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.theengineeringprojects.dani&quot; &gt;

    &lt;uses-feature android:name=&quot;android.hardware.usb.host&quot; /&gt;

    &lt;application
        android:allowBackup=&quot;true&quot;
        android:icon=&quot;@mipmap/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;
        android:supportsRtl=&quot;true&quot;
        android:theme=&quot;@style/AppTheme&quot; &gt;
        &lt;activity android:name=&quot;.MainActivity&quot; &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
            &lt;/intent-filter&gt;
            <ins>&lt;intent-filter&gt;
                &lt;action
                    android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot; /&gt;
            &lt;/intent-filter&gt;
            &lt;meta-data
                android:name=&quot;android.hardware.usb.action.USB_DEVICE_ATTACHED&quot;
                android:resource=&quot;@xml/device_filter&quot; /&gt;</ins>
        &lt;/activity&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</pre>
<p>La risorsa <span class="code">device_filter</span> citata nel manifesto è un file XML salvato nella cartella <span class="path">res</span> che specifica i dispositivi USB per i quali l'applicazione intende ricevere la notifica dell'evento <span class="code">USB_DEVICE_ATTACHED</span>. Ogni dispositivo USB è identificato univocamente da un insieme di codici numerici, specificatamente <em>vendor-id</em>, <em>product-id</em>, <em>class</em>, <em>subclass</em> e <em>protocol</em>. La pagina <a href="http://www.linux-usb.org/usb-ids.html">The USB ID Repository</a> contiene un elenco esaustivo di identificativi di dispositivi USB; uno più &laquo;ragionato&raquo; è invece reperibile nei sorgenti della libreria <a href="https://github.com/mik3y/usb-serial-for-android/blob/master/usbSerialExamples/src/main/res/xml/device_filter.xml">usb-serial-for-android</a>. Dagli elenchi si ricava il <em>vendor-id</em> associato ad Arduino, che è 9025 (esadecimale 0x2341). Il <em>product-id</em> varia a seconda della tipologia e della revisione della scheda; se non lo si indica, il sistema operativo invierà all'applicazione la notifica <span class="code">USB_DEVICE_ATTACHED</span> qualunque sia la scheda Arduino collegata al terminale Android. Il file <span class="path">device_filter.xml</span> assume quindi la forma:</p>
<pre class="code">
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;

&lt;resources&gt;
    &lt;!-- 0x2341 / Arduino --&gt;
    &lt;usb-device vendor-id=&quot;9025&quot; /&gt;
&lt;/resources&gt;
</pre>
<p>A questo punto, quando l'utente collega un dispositivo Arduindo al terminale Android il sistema operativo avvia l'applicazione se non è già attiva, e chiama il metodo <span class="code">onResume</span>; specializzando il metodo si ricava un riferimento all'oggetto <a href="https://developer.android.com/reference/android/hardware/usb/UsbDevice"><span class="code">UsbDevice</span></a> associato alla scheda direttamente dall'<span class="code">Intent</span> implicito attraverso il metodo <span class="code">getParcelableExtra</span>:</p>
<pre class="code">
public class MainActivity extends AppCompatActivity {
    ...

    @Override
    public void onResume() {
        super.onResume();

        <ins>Intent intent = getIntent();
        String action = intent.getAction();

        if (UsbManager.ACTION_USB_DEVICE_ATTACHED.equals(action)) {
            UsbDevice device =
                (UsbDevice)intent.getParcelableExtra(
                    UsbManager.EXTRA_DEVICE);
            ...
        }</ins>
    }
}
</pre>
<h3>Scansione dei dispositivi USB</h3>
<p>Il secondo metodo di individuazione della scheda Arduino consiste nell'effettuare una scansione periodica di tutti i dispositivi USB collegati al terminale Android alla ricerca del primo con <em>vendor-id</em> pari a 9025:</p>
<pre class="code">
    <ins>HashMap&lt;String, UsbDevice&gt; deviceList = usbManager.getDeviceList();
    Iterator&lt;UsbDevice&gt; deviceIterator = deviceList.values().iterator();

    while(deviceIterator.hasNext()) {
        UsbDevice usbDevice = deviceIterator.next();
        if (usbDevice.getVendorId() == 9025) {
            // this is an Arduino device!
            break;
        }
    }</ins>
</pre>
<p>Questa soluzione ha lo svantaggio che l'applicazione non viene avviata automaticamente in concomitanza con il collegamento della scheda Arduino al terminale Android.</p>
<h3>Scollegamento della scheda</h3>
<p>Android riconosce quando l'utente scollega un dispositivo USB dal terminale, ed è possibile richiedere al sistema operativo di inviare una notifica alla nostra applicazione al verificarsi di questa condizione. È sufficiente registrare l'applicazione sull'evento <span class="code">USB_DEVICE_DETACHED</span>, anche se non in modo dichiarativo come fatto per l'evento <span class="code">USB_DEVICE_ATTACHED</span> &mdash; modificando il file <span class="path">AndroidManifest.xml</span> &mdash; ma a <em>runtime</em>, sfruttando un <span class="code">BroadcastReceiver</span>. L'aggancio avviene in due fasi; dapprima si definisce il <em>listener</em>, che contiene il codice da eseguire alla disconnessione del dispositivo:</p>
<pre class="code">
public class MainActivity extends AppCompatActivity {
    ...

    <ins>// create a listener for the ACTION_USB_DEVICE_DETACHED event
    private final BroadcastReceiver usbReceiver = new BroadcastReceiver() {
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action)) {
                // an USB device has been detached!
            }
        }
    };</ins>
    ...
}
</pre>
<p>Si collega quindi il <em>listener</em> all'evento <span class="code">USB_DEVICE_DETACHED</span>, di norma durante la fase di inizializzazione dell'applicazione:</p>
<pre class="code">
public class MainActivity extends AppCompatActivity {
    ...

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ...

        <ins>// register the ACTION_USB_DEVICE_DETACHED event listener
        IntentFilter filter = new IntentFilter();
        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);
        registerReceiver(usbReceiver, filter);</ins>
        ...
    }
}
</pre>
<h3>Porta seriale (virtuale)</h3>
<p>Arduino si presenta sul bus USB come un <em>Communications Device Class</em> (CDC, cfr. sez. &ldquo;Communications Device Class&rdquo; in <a href="http://www.usb.org/developers/docs/devclass_docs/">USB Device Class Specifications</a>), ovvero un dispositivo di comunicazione. Si tratta di dispositivi compositi, dotati cioé di più interfacce; per poter instaurare un canale di comunicazione è dunque indispensabile individuare la giusta interfaccia. In questo contesto l'interfaccia cercata è dotata di due <em>endpoint</em> &mdash; uno di ingresso e uno d'uscita &mdash; che supporta il trasferimento <em>bulk</em>. Se un'interfaccia con tali caratteristiche viene individuata, si procede aprendo un canale di comunicazione verso il dispositivo e collegandolo all'interfaccia appena trovata:</p>
<pre class="code">
public class UsbPort {
    ...

    private UsbManager usbManager;
    private UsbDevice usbDevice;
    private UsbEndpoint usbInEndpoint;
    private UsbEndpoint usbOutEndpoint;
    private UsbInterface usbInterface;
    private UsbDeviceConnection usbConnection;
    ...

    public UsbPort(UsbManager manager) {
        usbManager = manager;
        reset();
    }
    ...

    <ins>private boolean attach(UsbDevice device) {

        usbInEndpoint = null;
        usbOutEndpoint = null;

        // search for a suitable interface,
        // i.e. one that supports bidirectional bulk transfers
        for (int i = 0; i &lt; device.getInterfaceCount(); i++) {

            UsbInterface iface = device.getInterface(i);
            int numOfEndpoints = iface.getEndpointCount();

            if (numOfEndpoints &gt; 1) {
                for (int j = 0; j &lt; numOfEndpoints; j++) {
                    if (iface.getEndpoint(j).getType() ==
                            UsbConstants.USB_ENDPOINT_XFER_BULK) {
                        if (iface.getEndpoint(j).getDirection()
                                == UsbConstants.USB_DIR_IN) {
                            usbInEndpoint = iface.getEndpoint(j);
                        } else if (iface.getEndpoint(j).getDirection()
                                == UsbConstants.USB_DIR_OUT) {
                            usbOutEndpoint = iface.getEndpoint(j);
                        }
                    }
                }

                if (usbInEndpoint != null &amp;&amp; usbOutEndpoint != null)
                    usbInterface = iface;
            }
        }

        if (usbInterface == null)
            return false;

        usbDevice = device;
        usbConnection = usbManager.openDevice(usbDevice);

        if (usbConnection == null)
            return false;

        return usbConnection.claimInterface(usbInterface, true);
    }</ins>
    ...

    private void reset() {
        usbConnection = null;
        usbInEndpoint = null;
        usbOutEndpoint = null;
        usbInterface = null;
        usbDevice = null;
    }
    ...

}
</pre>
<h3>Comunicazione seriale</h3>
<p>Il trasferimento di dati da/per la scheda Arduino si ottiene invocando il metodo <a href="https://developer.android.com/reference/android/hardware/usb/UsbDeviceConnection.html#bulkTransfer(android.hardware.usb.UsbEndpoint,%20byte[],%20int,%20int)"><span class="code">bulkTransfer</span></a> dell'oggetto <a href="https://developer.android.com/reference/android/hardware/usb/UsbDeviceConnection"><span class="code">UsbDeviceConnection</span></a>:</p>
<pre class="code">
public class UsbPort {
    ...

    <ins>public int send(byte[] data, int timeout) {
        if (usbConnection == null)
            return 0;
        return usbConnection.bulkTransfer(
            usbOutEndpoint, data, data.length, timeout);
    }</ins>

    <ins>public int receive(byte[] buffer, int timeout) {
        if (usbConnection == null)
            return -1;
        return usbConnection.bulkTransfer(
            usbInEndpoint, buffer, buffer.length, timeout);
    }</ins>
    ...
}
</pre>
<h3>Configurazione della porta seriale (virtuale)</h3>
<p>La configurazione della connessione avviene per mezzo del metodo <a href="https://developer.android.com/reference/android/hardware/usb/UsbDeviceConnection.html#controlTransfer(int,%20int,%20int,%20int,%20byte[],%20int,%20int,%20int)"><span class="code">controlTransfer</span></a> dell'oggetto <a href="https://developer.android.com/reference/android/hardware/usb/UsbDeviceConnection"><span class="code">UsbDeviceConnection</span></a>, cui per comodità accedo attraverso un <em>adapter</em>:</p>
<pre class="code">
public class UsbPort {
    ...

    private static final int CDC_SET_LINE_CODING        = 0x20;
    private static final int CDC_REQTYPE_HOST2DEVICE    = 0x21;
    private static final int CDC_SET_CONTROL_LINE_STATE = 0x22;

    private static final int CDC_CONTROL_LINE_OFF       = 0x0000;
    private static final int CDC_CONTROL_LINE_ON        = 0x0003;

    private static final int USB_TIMEOUT                = 5000; // ms
    ...

    <ins>private int setControlCommand(int request, int value, byte[] data) {
        return usbConnection.controlTransfer(
                CDC_REQTYPE_HOST2DEVICE,
                request,
                value,
                0,
                data,
                (data == null) ? 0 : data.length,
                USB_TIMEOUT);</ins>
    }
    ...
}
</pre>
<p>Il parametro <span class="code">bmRequestType</span> è impostato a <span class="code">0x21</span> perché si tratta di un trasferimento diretto verso l'interfaccia del dispositivo (cfr. <a href="https://www.beyondlogic.org/usbnutshell/usb6.shtml#SetupPacket">The Setup Packet</a> e la risposta <a href="https://stackoverflow.com/questions/10467846/explanation-about-controltransfer-in-android-to-set-up-the-usb-communication">explanation about controltransfer in android to set up the USB communication</a> in Stackoverflow per maggiori dettagli):</p>
<ul>
	<li><span class="code">B7</span>: direzione del trasferimento (Host&rarr;Device/Device&rarr;Host);</li>
	<li><span class="code">B6&div;B5</span>: tipo di richiesta (Standard, Class, Vendor, &hellip;);</li>
	<li><span class="code">B4&div;B0</span>: destinatario (Dispositivo, Intefaccia, Endpoint, &hellip;).</li>
</ul>
<p>Relativamente alla configurazione della seriale, i parametri assumono i seguenti significati (cfr. sez. 6.3.10 &laquo;SetLineCoding&raquo; del file PSTN120.pdf che si trova all'interno dell'archivio <a href="http://www.usb.org/developers/docs/devclass_docs/CDC1.2_WMC1.1_012011.zip">CDC1.2_WMC1.1_012011.zip</a> rilasciato dal consorzio USS-IF e contentente la documentazione ufficiale relativa alla classe di dispositivi CDC &mdash; <a href="files/arduino-android-usb/PSTN120.pdf">qui</a> una copia locale del file):</p>
<table cellspacing="0">
<tr><th>Parametro</th><th>Valore</th></tr>
<tr><td><span class="code">request</span></td><td><span class="code">0x20</span></td></tr>
<tr><td><span class="code">value</span></td><td>non utilizzato</td></tr>
<tr>
	<td><span class="code">data</span></td>
	<td>
		<p>array di 7 byte così ripartiti:</p>
		<ul>
			<li>4 byte per il <em>baud rate</em>;</li>
			<li>1 byte per il numero di bit di stop;</li>
			<li>1 byte per la parità;</li>
			<li>1 byte per la dimensione della parola.</li>
		<ul>
	</td>
</tr>
</table>
<p>Sapendo che lo sketch caricato su Arduino lavora a 57600 8N1, il metodo per configurare la porta seriale allo stesso modo è il seguente:</p>
<pre class="code">
public class UsbPort {
    ...

    <ins>public boolean connect(UsbDevice device) {

        if (attach(device) &amp;&amp; configure())
            return true;

        reset();
        return false;
    }</ins>
    ...

    <ins>private boolean configure() {
        final byte[] portConfigData = new byte[] {
                (byte) 0x00, // baud rate: 57600
                (byte) 0xE1,
                (byte) 0x00,
                (byte) 0x00,
                (byte) 0x00, // 1 stop bit
                (byte) 0x00, // no parity
                (byte) 0x08  // 8 data bits
        };

        setControlCommand(
                CDC_SET_LINE_CODING,
                0,
                portConfigData);

        setControlCommand(
                CDC_SET_CONTROL_LINE_STATE,
                CDC_CONTROL_LINE_ON,
                null);

        return true;
    }</ins>
    ...

}
</pre>
<p>Nella funzione compare una seconda chiamata al metodo <span class="code">setControlCommand</span>. Il suo scopo è abilitare le linee <em>DTR &ndash; Data Terminal Ready</em> e <em>RTS &ndash; Request To Send</em> per indicare ad Arduino che il terminale Android è disponibile e pronto a ricevere dati (cfr. sez. 6.3.12 &laquo;SetControlLineState&raquo; del file <a href="files/arduino-android-usb/PSTN120.pdf">PSTN120.pdf</a>). In questo caso i valori dei parametri sono:</p>
<table cellspacing="0">
<tr><th>Parametro</th><th>Valore</th></tr>
<tr><td><span class="code">request</span></td><td><span class="code">0x22</span></td></tr>
<tr>
	<td><span class="code">value</span></td>
	<td>
		<p>maschera di bit così ripartiti:</p>
		<ul>
			<li><span class="code">B15&div;B3</span>: riservati</li>
			<li><span class="code">B1</span>: RTS</li>
			<li><span class="code">B0</span>: DTR</li>
		</ul>
	</td>
</tr>
<tr><td><span class="code">data</span></td><td>non utilizzato</td></tr>
</table>
<p>Avendo attivato le linee DTR/RTS all'apertura della connessione, è buona norma disattivarle alla chiusura:</p>
<pre class="code">
public class UsbPort {
    ...

    <ins>public void disconnect() {
        detach();
    }</ins>
    ...

    <ins>private void detach() {

        if (usbConnection == null)
            return;

        setControlCommand(
                CDC_SET_CONTROL_LINE_STATE,
                CDC_CONTROL_LINE_OFF,
                null);

        usbConnection.releaseInterface(usbInterface);
        usbConnection.close();

        reset();
    }</ins>
    ...

}
</pre>
<p>Approntata una semplice applicazione costituita da un'unica attività che ciclicamente invia la stringa &ldquo;<strong>*** Test @ 57600 8N1 ***</strong>&rdquo; sulla porta seriale per poi porsi in attesa della risposta, ho potuto verificare che il codice funziona:</p>
<img src="img/arduino-android-usb/test-circuit.jpg">
<p class="illustration">Il circuito di test</p>
<img src="img/arduino-android-usb/debug-window.png">
<p class="illustration">L'esito del primo test di comunicazione</p>
<p>Si può notare che la prima trasmissione è fallita (indagando più approfonditamente si scopre che si tratta di un errore di timeout). La cosa è imputabile al fatto che all'apertura della connessione Arduino effettua un reset automatico che rende il sistema indisponibile per qualche secondo (cfr. <a href="http://playground.arduino.cc/Main/DisablingAutoResetOnSerialConnection">DisablingAutoResetOnSerialConnection</a> sui forum ufficiali).</p>
<h3>BufferOverflowException</h3>
<p>Sebbene la classe <span class="code">UsbPort</span> abbia dato buona prova di sè con l'echo seriale, lo stesso non è accaduto quando ho implementato il protocollo di comunicazione utilizzato dal programma di controllo del tabellone segnapunti, che prevede la trasmissione di un pacchetto di comando di 14 byte cui segue la risposta di Arduino, costituita da un unico byte:</p>
<pre class="code">
    private byte[] txBuffer = new byte[14];
    ...

    txBuffer[0] = 0x02;
    txBuffer[1] = 0x00;
    ...

    usbPort.send(txBuffer, TIMEOUT);

    byte[] response = new byte[] { NUL, };
    while (usbPort.receive(response, TIMEOUT) > 0)
        ;

    if (response[0] == NUL)
        timeoutCount += 1;
    else if (response[0] == ACK)
        ackCount += 1;
    else if (response[0] == NAK)
        nakCount += 1;
    else
        errorCount += 1;

    ...
</pre>
<p>L'applicazione terminava invariabilmente con errore dopo aver inviato non più di 3/4 pacchetti. Ho così scoperto che il metodo <span class="code">bulkTransfer</span> scarica tutti i dati ricevuti nel buffer predisposto, <a href="http://libusb.sourceforge.net/api-1.0/libusb_packetoverflow.html">anche se questi eccedono la sua capacità</a>. Conviene quindi allocare un buffer sufficientemente ampio da contenere il pacchetto più grande che si possa ricevere. Tale dimensione si ottiene dal metodo <a href="https://developer.android.com/reference/android/hardware/usb/UsbEndpoint.html#getMaxPacketSize()"><span class="code">getMaxPacketSize</span></a> dell'oggetto <a href="https://developer.android.com/reference/android/hardware/usb/UsbEndpoint"><span class="code">UsbEndpoint</span></a> associato al terminale d'ingresso (nel caso della scheda Arduino Uno è pari a 64):</p>
<pre class="code">
public class UsbPort {
    ...

    <ins>public int getSuggestedInputBufferSize() {
        return usbInEndpoint.getMaxPacketSize();
    }</ins>
    ...
}
</pre>
<p>Utilizzando tale valore come dimensione del buffer d'ingresso non si sono più verificati errori di sorta. Il codice completo della classe <span class="code">UsbPort</span> è scaricabile <a href="files/arduino-android-usb/UsbPort.java">qui</a>.</p>
<h2>Debug Wireless</h2>
<p>L'emulatore Android non supporta la porta USB, quindi il test dell'applicazione va fatto su un terminale reale. D'altra parte non è possibile utilizzare il debugger con l'applicativo remoto perché, dopo aver trasferito l'applicazione, la presa USB del terminale va scollegata dal PC e collegata alla scheda Arduino. Fortunatamente esiste la possibilità di attivare il <a href="https://developer.android.com/studio/command-line/adb#wireless">debug wireless</a>, purché il terminale Android non sia stato aperto (<em>rooted</em>) in precedenza.</p>
<p>Seguendo le istruzioni riportate nella domanda di Stackoverflow <a href="https://android.stackexchange.com/questions/49681/adb-connect-to-a-device-via-tcp-ip">ADB connect to a device via TCP/IP</a> sono riuscito ad attivare questa modalità di debuging. Quando il terminale Android è ancora connesso al PC, dare i seguenti comandi:</p>
<pre class="code">
$ cd ~/Android/Sdk/platform-tools
$ adb tcpip 5555
$ adb connect &lt;IP-DISPOSITIVO&gt;:5555
</pre>
<p>L'indirizzo IP del terminale si trova nelle proprietà della connessione Wi-Fi. Alternativamente si può usare il comando:</p>
<pre class="code">
$ adb shell netcfg
</pre>
<p>A questo punto si può scollegare il cavo USB e procedere con il debugging. Se si è interessati al log prodotto dall'applicazione, lo si può visualizzare sul terminale con il comando (cfr. <a href="https://developer.android.com/studio/debug/am-logcat">Write and View Logs with Logcat</a>):</p>
<pre class="code">
$ adb logcat
</pre>
<p>Per disconnettere il terminale Android dare il comando:</p>
<pre class="code">
$ adb disconnect &lt;IP-DISPOSITIVO&gt;:5555
</pre>
<p>Se non si specifica l'indirizzo, il comando disconnette tutti i dispositivi connessi:</p>
<pre class="code">
$ adb disconnect
</pre>
<p>Infine, per riattivare il debug via USB dare il comando:</p>
<pre class="code">
$ adb usb
</pre>
<p class="modification-notice">Pagina modificata il 09/09/2018</p>
</body>
</html>
