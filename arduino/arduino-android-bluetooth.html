<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<title>Controllo di Arduino da Android via Bluetooth</title>
<link href="../css/main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<p class="page-path"><a href="../index.html#arduino-android-bluetooth">risorse</a> | controllo di arduino da android via bluetooth</p>
<h1>Controllo di Arduino da Android via Bluetooth</h1>
<h2>Introduzione</h2>
<!--

HC-05

va alimentato a 5V, ma le linee TX/RX funzionano a 3.3V.

Pairing: chi dice che il pin è 0000, chi 1234 (su due datasheet diversi)

Arduino riconosce il livello 3.3V sul suo RX, quindi non c'è bisogno di adattare quel segnale.
La linea Arduino TX, che funziona a 5V, ha invece bisogno di essere abbassata ai 3.3V attesi dall'RX del modulo.

------------------------------------------------------------------

Secondo https://www.electronicwings.com/arduino/hc-05-bluetooth-module-interfacing-with-arduino-uno sembra basti un partitore:

 TX --------+
            |
           | |
           | | 1K
            |
            +-------------- RX
            |
            |
           | |
           | | 2K
            |
           GND

Non usano TX/RX di Arduino, ma i pin 2 come RX e 3 come TX:

#include<SoftwareSerial.h>

/* Create object named bt of the class SoftwareSerial */ 
SoftwareSerial bt(2,3); /* (Rx,Tx) */	


(SoftwareSerial è una dipendenza da scaricare!)
------------------------------------------------------------------


https://create.arduino.cc/projecthub/akshayjoseph666/interfacing-bluetooth-module-hc-05-with-arduino-uno-f5209b


The HC-05 can operate in two modes. One is Data mode and other is AT command mode. When the enable pin is "LOW" the HC-05 is in Data Mode. If that pin set as "HIGH" the module is in AT command mode. Here we operate this module in Data Mode.


[questi collegano direttamente RX/TX tra loro]


------------------------------------------------------------------


https://create.arduino.cc/projecthub/electropeak/getting-started-with-hc-05-bluetooth-module-arduino-e0ca81

C05 module has an internal 3.3v regulator and that is why you can connect it to 5v voltage. But we strongly recommend 3.3V voltage, since the logic of HC05 serial communication pins is 3.3V. Supplying 5V to the module can cause damage to the module.

In order to prevent the module from damages and make it work properly, you should use a resistance division circuit (5v to 3.3v ) between arduino TX pin and module RX pin.

When master and slave are connected, blue and red LEDs on the board blink every 2seconds. If they aren’t connected, only blue one blinks every 2 seconds.

[anche questi usano il partitore e le linee digitali 2 e 3 -> comodo perché lascia libera la seriale per debug]

#include <SoftwareSerial.h> 
SoftwareSerial MyBlue(2, 3); // RX | TX 

il pin 2 direttamente sul TX, il 3 su RX con partitore 2200/1100


-------------------------------------------------

questo sembra fatto bene:

http://www.martyncurrey.com/arduino-with-hc-05-bluetooth-module-at-mode/


1) sketch che fa da ponte tra PC e modulo. si lavora in modalità AT.

2) sketch che riceve i comandi dal modulo bluetooth.


=========================================================

comincio col circuito.
ho solo resistenze da 10K, faccio il partitore 10+10+10.
5 * 2/3 = 3.33, ma se provo, e alimento il partitore coica 5.2V che Arduino eroga,
arrivo a 3.4. Pericoloso? Sembra di no, in rete ci sono varie implementazioni che usano
questi valori (1K/2K) o simili (10K/4.7K). Ricordarsi di impostare il pin in uscita il più
presto possibile!
Sarebbe meglio 1K/2K per diminuire l'impedenza e distorcere il meno possibile i fronti del segnale.
(ma posso vedere con l'oscilloscopio il segnale con carico vs a vuoto)

passo 2: configurare il modulo coi comandi AT.
si aspetta 38400, con a-capo CR+LF.
Posso usare il serial monitor di Arduino dopo aver programmato arduino per fare da ponte.

sketch:

#include <SoftwareSerial.h>

const int tx_pin = 2; // pin connected to RXD
const int rx_pin = 3; // pin connected to TXD

SoftwareSerial hc05_serial(rx_pin, tx_pin);

void setup() {
  // open PC serial
  Serial.begin(9600);
  Serial.print("Sketch: ");
  Serial.println(__FILE__);
  Serial.print("Uploaded: ");
  Serial.println(__DATE__);
  Serial.println(" ");

  // open HC-05 serial
  hc05_serial.begin(38400);
  Serial.println("Hc05Serial ready");
  Serial.println(" ");
}

void loop() {
  // forward incoming HC-05 data to PC
  while (hc05_serial.available())
    Serial.write(hc05_serial.read());

  // forward incoming PC data to HC-05
  while (Serial.available())
    hc05_serial.write(Serial.read());
}


(SoftwareSerial non serve scaricarla, è inclusa nell'IDE).

Caricare lo sketch su Arduino.
Spegnere, riaccendere tenendo premuto il tasto del l'HC-05. (il led rosso deve lampeggiare)
aprire il serial monitor, impostarlo a 9600, "Both NL & CR"
inviare i caratteri "AT", si ottiene

OK

(consultare il manuale HC-05-ITead.pdf per i comandi supportati)


AT+VERSION?

+VERSION:4.0-20190815
OK


AT+NAME?

+NAME:HC-05
OK


AT+ROLE?

+ROLE:0
OK

0=SLAVE, 1=MASTER, 2=SLAVE-LOOP

Qual'è il PIN?

AT+PSWD?

+PSWD:1234
OK

Setup seriale?
AT+UART?

+UART:9600,0,0
OK


Tutto in linea con quanto riportato nel manuale "EGBT-045MS-046S Bluetooth Module Manual rev 1r0.pdf"
Il modulo è ok. si può procedere col terzo passo.



Prima lo verifico sulla seriale normale, poi mi sposto su quella dell'HC-05.

Ok col prototipo comandato da Serial Monitor:


#include <SoftwareSerial.h>

const int tx_pin = 2; // pin connected to RXD
const int rx_pin = 3; // pin connected to TXD

SoftwareSerial hc05_serial(rx_pin, tx_pin);

bool blink = false;

void setup() {
  // open PC serial
  Serial.begin(9600);
  Serial.print("Sketch: ");
  Serial.println(__FILE__);
  Serial.print("Uploaded: ");
  Serial.println(__DATE__);
  Serial.println(" ");

  // open HC-05 serial
  hc05_serial.begin(38400);
  Serial.println("Hc05Serial ready");
  Serial.println(" ");

  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  /*
  // forward incoming HC-05 data to PC
  while (hc05_serial.available())
    Serial.write(hc05_serial.read());

  // forward incoming PC data to HC-05
  while (Serial.available())
    hc05_serial.write(Serial.read());
  */
  if (Serial.available()) {
    switch (Serial.read()) {
      case '1':
        blink = false;
        digitalWrite(LED_BUILTIN, HIGH);
        break;
      case '2':
        blink = false;
        digitalWrite(LED_BUILTIN, LOW);
        break;
      case '3':
        blink = true;
        break;
      default:
        break;
    }
  }
  if (blink) {
    digitalWrite(LED_BUILTIN, HIGH);
    delay(250);
    digitalWrite(LED_BUILTIN, LOW);
  }
  delay(250);
}


'1': accende led
'2': spegne led
'3': lo fa lampeggiare

cambiare la seriale di controllo, spegnere e riaccendere per mettere HC-05 in modalità dati.


#include <SoftwareSerial.h>

const int tx_pin = 2; // pin connected to RXD
const int rx_pin = 3; // pin connected to TXD

SoftwareSerial hc05_serial(rx_pin, tx_pin);

bool blink = false;

void setup() {
  // open PC serial
  Serial.begin(9600);
  Serial.print("Sketch: ");
  Serial.println(__FILE__);
  Serial.print("Uploaded: ");
  Serial.println(__DATE__);
  Serial.println(" ");

  // open HC-05 serial
  hc05_serial.begin(38400);
  Serial.println("Hc05Serial ready");
  Serial.println(" ");

  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  /*
  // forward incoming HC-05 data to PC
  while (hc05_serial.available())
    Serial.write(hc05_serial.read());

  // forward incoming PC data to HC-05
  while (Serial.available())
    hc05_serial.write(Serial.read());
  */
  if (hc05_serial.available()) {
    int c = hc05_serial.read();
    Serial.write(c);
    switch (c) {
      case '1':
        blink = false;
        digitalWrite(LED_BUILTIN, HIGH);
        break;
      case '2':
        blink = false;
        digitalWrite(LED_BUILTIN, LOW);
        break;
      case '3':
        blink = true;
        break;
      default:
        break;
    }
  }
  if (blink) {
    digitalWrite(LED_BUILTIN, HIGH);
    delay(250);
    digitalWrite(LED_BUILTIN, LOW);
  }
  delay(250);
}


Accoppiare l'HC-05 col telefono, far partire l'app prototipo e provare...

Il dispositivo si connette, lo vedo
(led rosso lampeggia veloce quando disconnesso, spento quando connesso)
i comandi però non hanno effetto. problemi di configurazione della seriale?

Potrebbe essere, sul serial monitor appaiono i caratteri x⸮⸮

No, è la seriale verso il modulo che deve passare da 38400 a 9600!!

...
  Serial.println(" ");

  // open HC-05 serial
  hc05_serial.begin(38400); <------------------ 9600
  Serial.println("Hc05Serial ready");
...



FUNZIONA!!!


repository App: https://github.com/gzuliani/bt-remote
-->
<img src="img/arduino-android-bluetooth/wiring-diagram.png">
<p class="illustration">Lo schema elettrico</p>
<img src="img/arduino-android-bluetooth/schematic.png">
<p class="illustration">Il cablaggio del circuito</p>
<img src="img/arduino-android-bluetooth/circuit.jpg">
<p class="illustration">Realizzazione pratica del circuito</p>


<img src="img/arduino-android-bluetooth/serial-bridge.png">
<p class="illustration">Programmazione del componente HC-05</p>
<img src="img/arduino-android-bluetooth/serial-bluetooth.png">
<p class="illustration">Comunicazione tra Arduino e terminale Android</p>


<video width="600" controls>
 <source src="img/arduino-android-bluetooth/20201125_212159.mp4" type="video/mp4">
</video>
<p class="modification-notice">Pagina modificata il 25/11/2020</p>
</body>
</html>
