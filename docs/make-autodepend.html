<html>
<head>
<meta charset="UTF-8">
<title>Dipendenze automatiche con <span class="tool">make</span></title>
<link href="../css/main.css" rel="stylesheet" type="text/css"></link>
<link href="css/make-autodepend.css" rel="stylesheet" type="text/css"></link>
</head>
<body>
<p class="page-path"><a href="../index.html#xml-space">risorse</a> | dipendenze automatiche con make</p>
<h1>Dipendenze automatiche con <span class="tool">make</span></h1>
<h2>Introduzione</h2>
<p class="todo">bla bla bla... <span class="tool">make</span> bla bla bla... <span class="tool">Visual Studio 2013 Express for Windows Desktop</span> bla bla bla... <strong>solo dipendenze di compilazione</strong> bla bla bla...</p>
<h2>Il problema</h2>
<p>Supponiamo di dover compilare un unico file sorgente, <span class="file">main.cpp</span>, che include due file, <span class="file">a.h</span> e <span class="file">b.h</span>, il secondo dei quali include a sua volta il file <span class="file">c.h</span>:</p>
<pre class="code">
[main.cpp]
#include &lt;a.h&gt;
#include &lt;b.h&gt;

#include &lt;iostream&gt;

int main() {
  std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;
}
</pre>
<pre class="code">
[a.h]
// empty
</pre>
<pre class="code">
[b.h]
#include &lt;c.h&gt;
</pre>
<pre class="code">
[c.h]
// empty
</pre>
<p>Un possibile <span class="term">makefile</span> per la compilazione del sorgente è:</p>
<pre class="code">
[makefile]
main.obj: main.cpp
	@cl /c /EHsc /nologo main.cpp
</pre>
<p>Supponendo che i file sorgente e il makefile siano salvati nella stessa cartella, la compilazione avviene invocando <span class="tool">make</span><a href="#ref-1"><sup>[1]</sup></a> da un <span class="tool">Prompt dei comandi degli strumenti di VS2013</span>:</p>
<pre class="code">
C:\&hellip;&gt;set INCLUDE=.\;%INCLUDE%
C:\&hellip;&gt;make
main.cpp
</pre>
<p>Il file oggetto è stato quindi compilato. Chiamare nuovamente <span class="tool">make</span> non produce alcun effetto, com'è lecito attendersi:</p>
<pre class="code">
C:\&hellip;&gt;make
make: 'main.obj' is up to date.
</pre>
<p>Se il file <span class="file">main.cpp</span> viene modificato, la successiva invocazione di <span class="tool">make</span> causa la ricompilazione del file oggetto:</p>
<pre class="code">
C:\&hellip;&gt;rem modifica di main.cpp
C:\&hellip;&gt;make
main.cpp
</pre>
<p>Nulla accade però se si modifica uno qualunque dei file di inclusione:</p>
<pre class="code">
C:\&hellip;&gt;rem modifica di a.h, b.h e/o c.h
C:\&hellip;&gt;make
make: 'main.obj' is up to date.
</pre>
<p>Per fare in modo che il file oggetto venga aggiornato anche in seguito alla modifica di uno dei file di inclusione, è necessario elencare anch'essi tra i prerequisiti:</p>
<pre class="code">
[makefile]
main.obj: main.cpp <ins>a.h b.h c.h</ins>
	@cl /c /EHsc /nologo main.cpp
</pre>
<p>Avendo esplicitato le dipendenze dai file <span class="file">*.h</span>, il file oggetto viene ricompilato anche in seguito alla modifica di uno qualunque di essi:</p>
<pre class="code">
C:\&hellip;&gt;make
main.cpp
</pre>
<p>Non è pratico gestire manualmente questo tipo di dipendenze; sarebbe più comodo determinarle automaticamente.</p>
<h2>Determinazione delle dipendenze di compilazione</h2>
<p>Il compilatore C++ del <span class="tool">Visual Studio 2013</span> è in grado di produrre l'elenco dei file inclusi direttamente e indirettamente da un file C++<a href="#ref-7"><sup>[7]</sup></a>:</p>
<pre class="code">
C:\&hellip;&gt;cl /Zs /EHsc /nologo /showIncludes main.cpp
Includes main.cpp
main.cpp
Note: including file: .\a.h
Note: including file: .\b.h
Note: including file:  .\c.h
Note: including file: C:\Program Files (x86)\Microsoft Visual Studio 11.0\VC\&hellip;
&hellip;
</pre>
<p>&Egrave; dunque possibile ottenere automaticamente l'elenco delle dipendenze di un file sorgente; resta da capire come utilizzare questa informazione per raggiungere l'obiettivo.</p>
<h2>Generazione automatica dei prerequisiti</h2>
<p>Nella sezione 4.14 del manuale di <span class="tool">make</span><a href="#ref-4"><sup>[4]</sup></a>, intitolata &ldquo;Generating Prerequisites Automatically&rdquo;, si legge:</p>
<blockquote>The practice we recommend for automatic prerequisite generation is to have one makefile corresponding to each source file. For each source file name.c there is a makefile name.d which lists what files the object file name.o depends on. That way only the source files that have changed need to be rescanned to produce the new prerequisites.</blockquote>
<p>La documentazione suggerisce quindi di introdurre un nuovo makefile, denominato <span class="file">main.d</span>, nel quale specificare le dipendenze del relativo file sorgente:</p>
<pre class="code">
[main.d]
main.obj main.d : main.cpp a.h b.h c.h
</pre>
<p>La creazione di questo makefile ausiliario sarà demandato ad uno script apposito; per il momento ci accontentiamo di una soluzione <em>ad-hoc</em>:</p>
<pre class="code">
[make-d-file.cmd]
@echo main.obj main.d: main.cpp a.h b.h c.h&gt;main.d
</pre>
<p>La presenza del <span class="term">target</span> <span class="code">main.d</span> garantisce che in caso di modifiche al file sorgente o a una qualunque sua dipendenza, non solo il file oggetto viene ricompilato, ma vengono ricalcolate anche le dipendenze. Il makefile principale diventa:</p>
<pre class="code">
[makefile]
<ins>all: main.obj</ins>

<ins>%.d: %.cpp
	@make-d-file.cmd</ins>

%.obj: %.cpp
	@cl /c /EHsc /nologo &quot;$&lt;&quot;

<ins>include main.d</ins>
</pre>
<p>Questa nuova configurazione è equivalente alla precedente, ed è immediato verificare che il file oggetto viene ricompilato in seguito alla modifica di uno qualunque dei file:</p>
<pre class="code">
C:\&hellip;&gt;rem modifica di c.h
C:\&hellip;&gt;make
main.cpp
</pre>
<p>Nel caso venga modificato l'albero delle inclusioni del file <span class="file">main.cpp</span>, per esempio per l'introduzione di una nuova direttiva <span class="code">#include</span> nel file <span class="file">a.h</span>, avendo <span class="tool">make</span> già letto &ndash; tramite l'istruzione <span class="code">include main.d</span> &ndash; l'elenco non aggiornato delle dipendenze dal makefile <span class="file">main.d</span>, c'è il rischio che il file oggetto non venga aggiornato? No: <span class="tool">make</span> rivaluta da capo il makefile principale se anche uno solo dei makefile inclusi risulta aggiornato (cfr. sezione 3.5 del manuale di <span class="tool">make</span><a href="#ref-4"><sup>[4]</sup></a>, intitolata &ldquo;How Makefiles Are Remade&rdquo;):</p>
<blockquote>To this end, after reading in all makefiles, make will consider each as a goal target and attempt to update it. If a makefile has a rule which says how to update it (found either in that very makefile or in another one) or if an implicit rule applies to it (see Using Implicit Rules), it will be updated if necessary. After all makefiles have been checked, if any have actually been changed, make starts with a clean slate and reads all the makefiles over again. (It will also attempt to update each of them over again, but normally this will not change them again, since they are already up to date.)</blockquote>
<p>Per verificare che l'aggiornamento del makefile delle dipendenze <span class="file">main.d</span> causa la rivalutazione dell'intero makefile è sufficiente inserire una chiamata <span class="code">$(warning&hellip; )</span>, dopo aver specificato come produrre il makefile ausiliario:</p>
<pre class="code">
[makefile]
<ins>$(warning Running makefile...)</ins>

all: main.obj

%.d: %.cpp
	@make-d-file.cmd

%.obj: %.cpp
	@cl /c /EHsc /nologo &quot;$&lt;&quot;

include main.d
</pre>
<pre class="code">
C:\&hellip;&gt;make
makefile:1: Running makefile...
make: Nothing to be done for 'all'.

C:\&hellip;&gt;rem modifica di c.h
C:\&hellip;&gt;make
makefile:1: Running makefile...
makefile:1: Running makefile...
main.cpp
</pre>
<p>Se l'esecuzione del makefile richiede del tempo, questo comportamento potrebbe rivelarsi fastidioso, se non innaccettabile. Un altro aspetto &laquo;sgradevole&raquo; è che in assenza del makefile delle dipendenze, prima di crearlo <span class="tool">make</span> emette un avviso:</p>
<pre class="code">
C:\&hellip;&gt;del main.d
C:\&hellip;&gt;make
makefile:1: Running makefile...
makefile:11: main.d: No such file or directory
makefile:1: Running makefile...
make: Nothing to be done for &apos;all&apos;.
</pre>
<p>Infine, cosa ben più grave, in caso di cancellazione o rinomina di una dipendenza, <span class="tool">make</span> termina con un errore fatale:</p>
<pre class="code">
C:\&hellip;&gt;ren c.h c1.h
C:\&hellip;&gt;rem modifica l&apos;#include in b.h di conseguenza
C:\&hellip;&gt;make
makefile:1: Running makefile...
make: *** No rule to make target &apos;c.h&apos;, needed by &apos;main.d&apos;.  Stop.
</pre>
<p>Per uscire dall'<em>empasse</em> non resta che cancellare il file delle dipendenze e lanciare un nuovo <span class="tool">make</span>, dopo aver modificato di conseguenza il comando <span class="code">echo</span> che genera il file <span class="file">main.d</span>:</p>
<pre class="code">
[make-d-file]
@echo main.obj main.d : main.cpp a.h b.h c<ins>1</ins>.h >main.d
</pre>
<pre class="code">
C:\&hellip;&gt;del main.d
C:\&hellip;&gt;make
makefile:1: Running makefile...
makefile:11: main.d: No such file or directory
makefile:1: Running makefile...
main.cpp
</pre>
<h2>Generazione &ldquo;furba&rdquo; dei prerequisiti</h2>
<p>Tutti i problemi appena evidenziati sono stati brillantemente risolti da Tom Tromey, il cui metodo è alla base del meccanismo di generazione delle dipendenze di <a href="http://www.gnu.org/software/automake/automake.html">automake</a>. L'idea è di cambiare completamente punto di vista sul file delle dipendenze <span class="file">main.d</span>: anziché considerarlo come l'elenco delle dipendenze del file oggetto &ndash; e in quanto tale da creare <em>prima</em> della compilazione &ndash;, lo si può considerare come un'istantanea delle dipendenze scattata nell'istante della compilazione &ndash; e quindi prodotto <em>in concomitanza</em> con la compilazione.</p>
<p>Se uno o più prerequisiti sono cambiati, di fatto è inutile ricalcolare il nuovo elenco delle dipendenze: proprio per il fatto che almeno una di esse è stata modificata, il file oggetto <em>deve</em> essere ricompilato, e poco importa sapere a questo punto qual'è lo stato aggiornato delle dipendenze. Vale invece la pena conservare l'elenco delle nuove dipendenze per la prossima invocazione di <span class="tool">make</span>.</p>
<p>Con la nuova tecnica, <span class="code">main.d</span> non è più un <em>target</em> di <span class="tool">make</span>, ma un semplice sottoprodotto della compilazione; la regola <span class="code">%.d: %.cpp</span> è quindi superflua. Per la stessa ragione, l'istruzione <span class="code">include</span> non causa più la rivalutazione del makefile principale, ed è quindi lecito ignorare l'errore emesso in caso di file non disponibile:</p>
<pre class="code">
[make-d-file]
@echo main.obj <del>main.d</del> : main.cpp a.h b.h c1.h&gt;main.d
</pre>
<pre class="code">
[makefile]
$(warning Executing makefile...)

all: main.obj

<del>%.d: %.cpp
	@make-d-file.cmd</del>

%.obj: %.cpp
	@cl /c /EHsc /nologo &quot;$&lt;&quot;
	<ins>@make-d-file.cmd</ins>

<ins>-</ins>include main.d
</pre>
<p>Il nuovo makefile non presenta più problema della doppia esecuzione:</p>
<pre class="code">
C:\&hellip;&gt;rem modifica di a.h
C:\&hellip;&gt;make
makefile:1: Running makefile...
main.cpp
</pre>
<p>L'assenza del file delle dipendenze non genera più la condizione d'errore vista prima:</p>
<pre class="code">
C:\&hellip;&gt;del main.d
C:\&hellip;&gt;make
makefile:1: Running makefile...
make: Nothing to be done for &apos;all&apos;.
</pre>
<p>Resta il problema dell'errore fatale nel caso uno dei prerequisiti di <span class="file">main.d</span> non sia reperibile:</p>
<pre class="code">
C:\&hellip;&gt;ren c1.h c.h
C:\&hellip;&gt;rem modifica b.h di conseguenza
C:\&hellip;&gt;rem modifica make-d-file.cmd di conseguenza
C:\&hellip;&gt;make
makefile:1: Running makefile...
make: *** No rule to make target &apos;c1.h&apos;, needed by &apos;main.d&apos;.  Stop.
</pre>
<p>Anche questo problema è di facile soluzione, grazie ad una peculiarità di <span class="tool">make</span> (cfr. sezione 4.7 &ldquo;Rules without Recipes or Prerequisites&rdquo; del manuale<a href="#ref-4"><sup>[4]</sup></a>):</p>
<blockquote>If a rule has no prerequisites or recipe, and the target of the rule is a nonexistent file, then make imagines this target to have been updated whenever its rule is run. This implies that all targets depending on this one will always have their recipe run.</blockquote>
<p>&Egrave; dunque sufficiente aggiungere, per ogni dipendenza, un <em>target</em> senza prerequisiti nè comandi:</p>
<pre class="code">
[make-d-file]
@echo main.obj main.d: main.cpp a.h b.h c.h&gt;main.d
@echo a.h:&gt;&gt;main.d
@echo b.h:&gt;&gt;main.d
@echo c.h:&gt;&gt;main.d
</pre>
<pre class="code">
C:\&hellip;&gt;del main.obj
C:\&hellip;&gt;make
makefile:1: Running makefile...
main.cpp

C:\&hellip;&gt;ren c.h c1.h
C:\&hellip;&gt;rem modifica b.h di conseguenza
C:\&hellip;&gt;rem modifica make-d-file.cmd di conseguenza
C:\&hellip;&gt;make
makefile:1: Running makefile...
main.cpp
</pre>
<h2>Generazione automatica del file delle dipendenze</h2>
<p>Grazie al flag <span class="code">/showIncludes</span> è facile approntare uno script python che, ricevuto in ingresso l'<em>output</em> del compilatore, produce il file <span class="file">*.d</span> associato al sorgente in fase di compilazione:</p>
<pre class="code">
[make-d-file.py]
import optparse
import os.path
import re
import subprocess
import sys

INCLUDING_FILE = &quot;Nota: file incluso&quot; # warning, localized text!
INCLUDING_FILE_LEN = len(INCLUDING_FILE)

def to_unix_path(path):
    return path.replace(&quot;\\&quot;, &quot;/&quot;).replace(&quot; &quot;, &quot;\\ &quot;)

if __name__ == &quot;__main__&quot;:

    parser = optparse.OptionParser(
        usage=&quot;usage: %prog &lt;object&gt; &lt;source&gt; [options]&quot;)
    parser.add_option(&quot;-o&quot;, &quot;&quot;, dest=&quot;file&quot;, default=&quot;&quot;,
        help=&quot;write to &lt;FILE&gt; instead of STDOUT&quot;)
    (options, args) = parser.parse_args()

    if len(args) != 2:
        parser.error(&quot;incorrect number of arguments&quot;)

    target = args[0]
    source = args[1]

    paths = []
    for line in sys.stdin:
        if line.startswith(INCLUDING_FILE):
            paths.append(to_unix_path(line[INCLUDING_FILE_LEN:].strip()))
        else:
            sys.stdout.write(line)

    if options.file:
        output = open(options.file, &quot;w&quot;)
    else:
        output = sys.stdout

    output.write(&quot;{0} : {1}&quot;.format(target, source))
    for path in paths:
        output.write(&quot; \\\n\t%s&quot; % path)
    output.write(&quot;\n\n&quot;)
    for path in paths:
        output.write(&quot;%s :\n&quot; % path)
</pre>
<p>Il makefile diventa:</p>
<pre class="code">
$(warning Executing makefile...)

all: main.obj

%.obj: %.cpp
	@cl /c /EHsc /nologo <ins>/showIncludes</ins> &quot;$&lt;&quot; <ins>/Fo:&quot;$@&quot; | %PYTHON% make-d-file.py &quot;$@&quot; &quot;$&lt;&quot; -o &quot;$*.d&quot;</ins>
	<del>@make-d-file.cmd</del>

-include main.d
</pre>
<!--
CASO REALE

caratteristiche del progetto:
albero delle directory
INCLUDE non "sporcata", contiene solo quelle di default (quella di progetto passata via /I):
per come funziona /showIncludes, che riporta il path assoluto, lo script deve togliere
il prefisso dal file.

Es. cartella di include: C:\MyProject
file di include in C:\MyProject\a.h
allora, se sono in C:\MyProject,  cl /showIncludes /IC:\MyProject ritorna "C:\MyProject\a.h"
se faccio (equivalente!) cl /showIncludes /I. -> ".\a.h"
se faccio (equivalente!) cl /showIncludes /I.\ -> ".\a.h"
se faccio (equivalente!) cl /showIncludes /I..\MyProject -> "..\MyProject\a.h"

allora passo tutte le /I allo script che in caso di match le toglie;
di più, così evito le dipendenze da quelle di sistema (%INCLUDE%)!!!

[makefile]
$(warning Executing makefile...)

all: main.obj

includedir=.

%.obj: %.cpp
	@cl /c /I$(includedir) /EHsc /nologo /showIncludes "$<" | C:\Python26\python.exe make-depend.py "$<" -s -i $(includedir) -o "$*.d"

-include main.d






e per strutture di cartelle più complicate? regge la cosa?
es.

makefile
build
include\lib1\a.h
include\lib1\b.h
include\lib2\c.h
include\lib2\d.h
src\main.cpp



[makefile]
$(warning Executing makefile...)

all: build/main.obj

includedir=include

build/%.obj: src/%.cpp
	@cl /c /I$(includedir) /EHsc /nologo /showIncludes "$<" /Fo"$@" | @C:\Python26\python.exe make-depend.py "$@" "$<" "build/$*.d" -i $(includedir) -o "build/$*.d"

-include main.d


bisogna passare esplicitamente:
1) target (build/main.obj)
2) path completo al sorgente (src/main.cpp)
3) path completo del file .d (in questo caso salvato con l'obj):

questo perché la prima riga del file.d dev'essere:

build/main.obj <d-folder>/main.d : src/main.cpp \
	...

per il resto, passando il parametro -i corretto, i .h sono già a posto.




e se per sbaglio cancello il file .d?
l'invocazione del make non lo ricostruisce, col risultato che finché non
modifico il cpp, le dipendenze non vengono rigenerate: cambio un .h e il cpp
non viene ricompilato...

devo forzare la ricompilazione dei file senza *.d
com'è adesso non posso far dipendere l'obj dal .d, perché essendo il .d più giovane,
make ricreerebbe l'obj ogni volta. se vogliamo seguire questa strada,
bisogna creare *prima* il .d, poi il .obj:







DOVE METTO I FILE .d? in una cartella apposta, fuori versionamento

-->

<h2>Riferimenti</h2>
<ol>
<a name="ref-1"></a>
<li>Lavavej, S. T. &ldquo;MinGW Distro&rdquo;. <em>nuwen.net</em>. &lt;<a href="http://nuwen.net/mingw.html">http://nuwen.net/mingw.html</a>&gt;. Visitato il 18/09/2014.</li>
<a name="ref-2"></a>
<li>McPeak, S. &ldquo;Autodependencies with GNU make&rdquo;. <em>scottmcpeak.com</em>. &lt;<a href="http://scottmcpeak.com/autodepend/autodepend.html">http://scottmcpeak.com/autodepend/autodepend.html</a>&gt;. Visitato il 18/09/2014.</li>
<a name="ref-3"></a>
<li>&ldquo;Advanced Auto-Dependency Generation&rdquo;. <em>mad-scientist.net</em>. &lt;<a href="http://mad-scientist.net/make/autodep.html">http://mad-scientist.net/make/autodep.html</a>&gt;. Visitato il 18/09/2014.</li>
<a name="ref-4"></a>
<li>&ldquo;GNU `make'&rdquo;. <em>GNU Operating System</em>. &lt;<a href="http://www.gnu.org/software/make/manual/make.html">http://www.gnu.org/software/make/manual/make.html</a>&gt;. Visitato il 18/09/2014.</li>
<a name="ref-5"></a>
<li>&ldquo;How to Get Dependencies from /showIncludes&rdquo;. <em>The Conifer Systems Blog</em>. &lt;<a href="http://www.conifersystems.com/2008/10/09/dependencies-from-showincludes/">http://www.conifersystems.com/2008/10/09/dependencies-from-showincludes/</a>&gt;. Visitato il 18/09/2014.</li>
<a name="ref-6"></a>
<li>&ldquo;Solving the Dependency Problem in Software Build&rdquo;. <em>Electric Cloud</em>. &lt;<a href="http://electric-cloud.com/wp-content/uploads/2014/06/Solving-the-Dep-Prob-Sftw-Blds.pdf">http://electric-cloud.com/wp-content/uploads/2014/06/Solving-the-Dep-Prob-Sftw-Blds.pdf</a>&gt;. Visitato il 18/09/2014.</li>
<a name="ref-7"></a>
<li>&ldquo;/showIncludes (List Include Files)&rdquo;. <em>MSDN</em>. &lt;<a href="http://msdn.microsoft.com/en-us/library/hdkef6tk.aspx">http://msdn.microsoft.com/en-us/library/hdkef6tk.aspx</a>&gt;. Visitato il 18/09/2014.</li>
</ol>
<p class="modification-notice">Pagina modificata il 19/09/2014</p>
</body>
</html>
