<html>
<head>
<meta charset="UTF-8">
<title>Bluetooth, C++ e Android</title>
<link href="../css/main.css" rel="stylesheet" type="text/css"></link>
<link href="css/bluetooth-cpp-android.css" rel="stylesheet" type="text/css"></link>
</head>
<body>
<p class="page-path"><a href="../index.html#bluetooth-cpp-android">risorse</a> | bluetooth c++ e android</p>
<h1>Bluetooth, C++ e Android</h1>
<p>Nel corso degli anni ho sviluppato un applicativo C++ su Windows per il controllo di uno strumento di misura: il programma si connette allo strumento via Bluetooth e scarica i dati acquisiti attraverso un protocollo di comunicazione binario specifico, ideato dal costruttore del multimetro. I dati raccolti vengono presentati all'utente e archiviati per consentire analisi di varia natura.</p>
<p>Poco più di un anno fa ho effettuato uno studio di fattibilità circa il <em>porting</em> dell'applicativo su dispositivo mobile, nella fattispecie un terminale Android. Raccolgo qui qualche appunto circa le difficoltà incontrate nell'accedere al trasmettitore Bluetooth di un dispositivo Android da una libreria nativa.</p>
<h2>Premessa</h2>
<p>Considerando la complessità dell'implementazione del protocollo di comunicazione, il presupposto iniziale è stato quello di riutilizzare il codice C++ di acquisizione dei dati, lasciando all'applicativo Java la responsabilità della loro visualizzazione e memorizzazione. La reimplementazione del protocollo di comunicazione in Java è stato escluso a priori.</p>
<h2>Interfaccia Java/C++</h2>
<p>Ho prima di tutto riorganizzato il codice C++ di comunicazione ed elaborazione dei dati in una libreria dinamica <span class="library">myLib</span>, che successivamente ho portato in ambiente Linux.</p>
<p class="note">Il porting del codice C++ da Windows a Linux è stata un'esperienza particolarmente istruttiva. Per quanto pensassi di aver sviluppato codice tutto sommato indipendente dalla piattaforma utilizzata (Win32), l'operazione ha richiesto un discreto numero di interventi correttivi. Altrettanto formativo è stato compilare lo stesso codice utilizzando compilatori diversi: le sorprese non sono mancate!</p>
<p>In seconda istanza ho definito un'interfaccia C per agevolare l'accesso alle funzionalità implementate dalla libreria <em>nativa</em> (implementata in C/C++); per comodità ho scelto di utilizzare i tipi primitivi del linguaggio C come parametri di ingresso/uscita, optando per l'utilizzo di stringhe JSON come valore di ritorno per tutte le funzioni:</p>
<pre class="code">
extern "C" {
  const char* method(int value);
}
</pre>
<p class="illustration">Esempio di API C esposta dalla libreria nativa <span class="library">myLib.so</span></p>
<p>L'accesso all'API nativa da parte dell'applicativo Java avviene attraverso una classe dedicata:</p>
<pre class="code">
public class NativeAPI {
  static {
    System.loadLibrary("myLib_wrapper");
  }
  public native String method(int aValue);
  ...
}
</pre>
<p>Come si può dedurre dal frammento di codice, l'applicazione Java accede alla libreria nativa attraverso una libreria ausiliaria, denominata <span class="library">myLib_wrapper</span>, che si occupa di effettuare il <em>marshalling</em> dei parametri di ingresso e del valore di ritorno, oltre ovviamente dell'invocazione del metodo nativo:</p>
<pre class="code">
extern "C" {
  JNIEXPORT jstring JNICALL Java_xx_company_product_MyLib_method(
    JNIEnv* env, jobject thiz, jint value) {
    return env->NewStringUTF(method(value));
  }
}
</pre>
<p class="illustration">Esempio di <em>wrapping</em> dell'API nativa <span class="code">method</span> &mdash; notare il <em>mangling</em> (decorazione) del nome del metodo</p>
<h2>Accesso al Bluetooth</h2>
<p>La compilazione della libreria nativa <span class="library">myLib.so</span> con l'NDK per Android non va a buon fine, perché il Bluetooth su quella piattaforma non è (ancora?) disponibile &mdash; cfr. <a href="https://developer.android.com/ndk/guides/stable_apis.html">Android NDK Native APIs</a>. Il problema è noto, e il suggerimento più comune è quello di fornire alla libreria nativa un accesso al Bluetooth attraverso un oggetto Java.</p>
<p>Fortunatamente il codice C++ originale già astraeva dalla tipologia di connessione: il modulo che implementa il protocollo di comunicazione infatti, dovendo supportare la doppia modalità di connessione Bluetooth/Seriale, già basava il suo funzionamento su una classe astratta denominata <span class="code">Connection</span>. Estenderlo per supportare un terzo tipo di connessione non avrebbe dovuto rivelarsi troppo difficile:</p>
<pre class="code">
class Connection {
public:
  virtual ~Connection() = default;
  virtual int send(const char* data, int count) = 0;
  virtual int receive(char* data, int expected) = 0;
};

class SerialConnection : public Connection {
    ...
};

class BluetoothConnection : public Connection {
    ...
};
</pre>
<p class="illustration">La classe astratta <span class="code">Connection</span> e le due implementazioni originali</p>
<p>La definizione della classe Java che modella la connessione Bluetooth non è molto diversa:</p>
<pre class="code">
public class BluetoothConnection {
  public BluetoothConnection(String address, int timeout) throws IOException
  public boolean isOpen() ...
  public boolean open() throws Exception ...
  public boolean close() throws Exception ...
  public int send(byte[] buffer) throws IOException ...
  public byte[] receive(int bytesToRead) throws IOException ...
  ...
}
</pre>
<p class="illustration">La classe Java per l'accesso al Bluetooth</p>
<p>Occorre a questo punto arricchire l'API Java/C++ per consentire all'applicativo di passare alla libreria nativa sottostante un'istanza di questa classe:</p>
<pre class="code">
// myLib
extern "C" {
  const char* method(int value);
  <strong>const char* initialize(JNIEnv* env, jobject connection);</strong>
}
</pre>
<pre class="code">
// Java
public class NativeAPI {
  static {
    System.loadLibrary("myLib_wrapper");
  }
  public native String method(int aValue);
  <strong>public native String initialize(BluetoothConnection connection);</strong>
  ...
}
</pre>
<pre class="code">
// myLib_wrapper
extern "C" {
  JNIEXPORT jstring JNICALL Java_xx_company_product_MyLib_method(
    JNIEnv* env, jobject thiz, jint value) {
    return env->NewStringUTF(method(value));
  }
  <strong>JNIEXPORT jstring JNICALL Java_xx_company_product_MyLib_initialize(
    JNIEnv* env, jobject thiz, jobject connection) {
    return env->NewStringUTF(initialize(env, connection));
  }</strong>
}
</pre>
<p>Resta da specializzare l'oggetto C++ <span class="code">Connection</span> fornendo un'implementazione basata sull'oggetto Java <span class="code">BluetoothConnection</span>:</p>
<pre class="code">
<strong>class JavaConnection : public Connection {
  JNIEnv* env_;
  jobject connection_;
  ...
public:
  JavaConnection(JNIEnv* env, jobject connection);
  ~JavaConnection();
  int send(const char* data, int count) override;
  int receive(char* data, int expected) override;
  ...
};</strong>
</pre>
<p>Il diagramma che segue illustra le classi e le interfacce fin qui descritte, con le rispettive dipendenze:</p>
<a href="img/bluetooth-cpp-android/invoke-class-diagram.png">
<img src="img/bluetooth-cpp-android/invoke-class-diagram.png" width="500"/>
</a>
<p class="illustration"><em>Class diagram</em> dell'implementazione (click sull'immagine per ingrandirla).</p>
<p>Nel diagramma appaiono due oggetti fittizi di comodo: il primo, <span class="code">Facade</span>, rappresenta l'interfaccia C della libreria nativa <span class="library">myLib</span>, mentre il secondo, <span class="code">Wrapper</span>, raggruppa le funzioni di marshalling dei parametri tra Java e C contenute nella libreria ausiliaria <span class="library">myLib_wrapper</span>.</p>
<h2>Sequenza di chiamate</h2>
<p>L'utilizzo della libreria nativa si articola in tre fasi: il caricamento e l'inizializzazione della libreria, che comprende il passaggio di un'istanza della classe Java <span class="code">BluetoothConnection</span>, l'invocazione dei metodi necessari al raggiungimento dell'obiettivo prefissato, quindi lo scaricamento della libreria:</p>
<pre class="code">
  BluetoothConnection connection = new BluetoothConnection(...);
  ...

  // initialization
  NativeAPI aNativeAPI = new NativeAPI();
  aNativeAPI.initialize(connection);
  ...

  // using the native API
  String result = aNativeAPI.method(anIntValue);
  ...

  // finalization
  aNativeAPI.finalize();
  ...
</pre>
<p>Il diagramma che segue illustra la sequenza di chiamate in ognuna delle tre fasi:</p>
<a href="img/bluetooth-cpp-android/invoke-sequence-diagram.png">
<img src="img/bluetooth-cpp-android/invoke-sequence-diagram.png" width="800"/>
</a>
<p class="illustration"><em>Sequence diagram</em> del tipico caso d'uso dell'API (click sull'immagine per ingrandirla).</p>
<h3>Inizializzazione &ndash; &ldquo;Set up&rdquo;</h3>
<p>La libreria nativa <span class="library">myLib</span> viene caricata in memoria dal runtime Java in corrispondenza del primo riferimento alla classe <span class="code">NativeAPI</span> (cfr. messaggi <span class="message">[4]</span>, <span class="message">[5]</span> e <span class="message">[6]</span>). L'inizializzazione della libreria avviene esplicitamente, con la chiamata <span class="code">initialize</span> del medesimo oggetto (<span class="message">[7]</span>), che causa l'esecuzione dell'omonimo metodo della libreria di marshalling (<span class="message">[8]</span>), il quale a sua volta chiama in causa la libreria nativa (<span class="message">[9]</span>). Il codice C++ riceve così un riferimento all'oggetto Java <span class="code">BluetoothConnection</span>, che viene immediatamente &ldquo;impacchettato&rdquo; all'interno di un oggetto C++ di tipo <span class="code">JavaConnection</span> (<span class="message">[10]</span>). Con l'occasione, la libreria nativa apre subito il canale di comunicazione Bluetooth (<span class="message">[11]</span>), operazione che viene effettivamente condotta dall'oggetto <span class="code">BluetoothConnection</span> nel contesto dell'applicazione Java (<span class="message">[12]</span>).</p>
<h3>Uso dell'API &ndash; &ldquo;Usage&rdquo;</h3>
<p>La chiamata di un metodo nativo segue un tragitto analogo: il codice applicativo invoca un metodo dell'oggetto <span class="code">NativeAPI</span> (messaggio <span class="message">[19]</span>), che attiva il codice di marshalling ad esso associato (<span class="message">[20]</span>), il quale invoca l'omologo nativo (<span class="message">[21]</span>) che a sua volta sfrutta l'oggetto <span class="code">JavaConnection</span> per colloquiare con lo strumento remoto per mezzo dell'oggetto Java <span class="code">BluetoothConnection</span>  (messaggi <span class="message">[22]</span>, <span class="message">[23]</span> e <span class="message">[26]</span>, <span class="message">[27]</span>). Il risultato dell'operazione segue il percorso inverso: dalla libreria nativa il responso passa a quella di marshalling (<span class="message">[30]</span>), da questa all'oggetto <span class="code">NativeAPI</span> (<span class="message">[31]</span>), infine all'applicativo (<span class="message">[32]</span>).</p>
<h3>Scaricamento &ndash; &ldquo;Tear down&rdquo;</h3>
<p>Il segnale che i servizi offerti dalla libreria non sono più richiesti è dato dalla chiamata del metodo <span class="code">finalize</span> dell'oggetto <span class="code">NativeAPI</span> (messaggio <span class="message">34</span>). La chiamata viene propagata alla libreria nativa (messaggi <span class="message">35</span> e <span class="message">36</span>) che dapprima provvede a chiudere la connessione (messaggi <span class="message">37</span> e <span class="message">38</span>), quindi a distruggere l'oggetto <em>envelope</em> <span class="code">JavaConnection</span>. Le librerie verranno scaricate dalla memoria quando il <em>garbage collector</em> di Java reclamerà l'oggetto <span class="code">NativeAPI</span> (messaggi <span class="message">45</span>, &hellip; <span class="message">49</span>).</p>
<h2>Callback</h2>
<p>Poiché il trasferimento dei dati acquisiti dallo strumento può richiedere svariati secondi, è indispensabile permettere al software applicativo di fornire all'utente un'indicazione circa lo stato di avanzamento del processo e, ove possibile, di annullarlo. A tal scopo alcuni metodi dell'interfaccia C nativa accettano un puntatore a una funzione (<em>callback</em>) che viene periodicamente chiamata dal codice della libreria per mettere al corrente il codice <em>client</em> di monitorare il progredire dell'elaborazione:</p>
<pre class="code">
extern "C" {
  ...

  <strong>// callback function type
  typedef int (*callback_fn)(const char* event, int data, void* param);</strong>

  // `method` has been extended to accept a callback
  const char* method(int value<strong>, callback_fn callback, void* param);</strong>
  ...
}
</pre>
<p class="illustration">Esempio di implementazione di callback in C</p>
<p>D'altra parte, Java non supporta funzioni globali quindi, in quel contesto, una callback deve essere necessariamente modellata come una classe:</p>
<pre class="code">
// Java
<strong>public class Callback {
  public int invoke(String anEvent, int aData) {
    ...
  }
}</strong>
</pre>
<p class="illustration">Possibile implementazione di una callback in Java</p>
<pre class="code">
public class NativeAPI {
  static {
    System.loadLibrary("myLib_wrapper");
  }
  public native String method(int aValue<strong>, Callback aCallback</strong>);
  public native String initialize(BluetoothConnection connection);
  ...
}
</pre>
<p class="illustration">Estensione dell'API <span class="code">method</span>: ora prevede un'interfaccia di notifica aggiuntiva</p>
<p>Serve ora collegare tra loro la callback C e la classe <span class="code">Callback</span>; per la sua natura, il codice di collegamento risiederà nella libreria di marshalling <span class="library">myLib_wrapper</span>. Si rendono necessari due componenti: un oggetto C++ che modella l'oggetto Java <span class="code">Callback</span> e una funzione di callback C da passare alla libreria nativa, e che si occuperà di inoltrare le notifiche ricevute dalla libreria alla <span class="code">Callback</span> Java. Il codice (semplificato!) del <em>wrapper</em> di <span class="code">Callback</span> è:</p>
<pre class="code">
<strong>class WrappedCallback {
  JNIEnv* env_;
  jobject callbackObject_;
  jmethodID invokeMethodId_;
public:
  WrappedCallback(JNIEnv* env, jobject callback)
   : env_(env), callbackObject_(callback) {
    jclass cls = env_-&gt;FindClass(&quot;xx/company/product/Callback&quot;);
    invokeMethodId_ = env_-&gt;GetMethodID(cls, &quot;invoke&quot;, &quot;(Ljava/lang/String;I)I&quot;);
  }
  int operator()(const char* event, int data) const {
    jstring str = env_-&gt;NewStringUTF(event);
    const int result = static_cast&lt;int&gt;(
      env_-&gt;CallIntMethod(callbackObject_, invokeMethodId_, str, data));
    env_-&gt;DeleteLocalRef(str);
    return result;
  }
};</strong>
</pre>
<p class="illustration">Possibile implementazione della modellizzazione dell'oggetto Java <span class="code">Callback</span></p>
<p>L'oggetto C++ <span class="code">WrappedCallback</span> conserva due riferimenti: il primo è quello dell'istanza dell'oggetto Java <span class="code">Callback</span> passata nel costruttore, il secondo al metodo <span class="code">invoke</span> della classe stessa. Quando viene innescato &ndash; tramite l'operatore <em>function call</em> &ndash;, esso inoltra il messaggio all'oggetto Java collegato, attivando il metodo <span class="code">invoke</span> sull'istanza di cui possiede il riferimento, passando i valori dei parametri ricevuti in ingresso. Restituisce infine al chiamante il valore di ritorno ottenuto in risposta dall'oggetto Java.</p>
<p>La forma assunta dalla callback C che la libreria ausiliaria passa a quella nativa è la seguente:</p>
<pre class="code">
extern &quot;C&quot; {
  ...

  <strong>int wrapper_callback(const char* event, int data, void* param) {
    // retrieve and invoke... what WrappedCallback object?!
  }</strong>
}
</pre>
<p class="illustration">Il &ldquo;guscio&rdquo; della callback della libreria wrapper</p>
<p>Il problema è evidente: come si fa ad ottenere un riferimento all'oggetto C++ <span class="code">Callback</span> da usare come ponte verso l'istanza <span class="code">Callback</span> Java? Chi l'ha creato? Quando? Rispondere a queste due ultime domande è semplice: l'oggetto è stato creato dalla stessa liberia di wrapping, prima di attivare il metodo nativo:</p>
<pre class="code">
extern "C" {
  ...

  <strong>JNIEXPORT jstring JNICALL Java_xx_company_product_MyLib_method(
    JNIEnv* env, jobject thiz, jint value, jobject callback) {
    register_callback(env, WrappedCallback(env, callback));
    return env-&gt;NewStringUTF(method(
      value, wrapper_callback, reinterpret_cast&lt;void*&gt;(env)));
  }</strong>
}
</pre>
<p class="illustration">Possibile esempio di wrapping di un metodo con callback</p>
<p><span class="code">wrapper_callback</span> può ora sfruttare il puntatore a <span class="code">env</span> passatole in <span class="code">param</span> per recuperare l'oggetto <span class="code">WrappedCallback</span>ad esso associato:</p>
<pre class="code">
extern &quot;C&quot; {
  ...

  int wrapper_callback(const char* event, int data, void* param) {
    // retrieve and invoke the WrappedCallback
    <strong>JNIEnv* env = reinterpret_cast&lt;JNIEnv*&gt;(param);
    WrappedCallback&amp; callback = find_callback(env);
    return callback(event, data);</strong>
  }
}
</pre>
<p><span class="code">register_callback</span> e <span class="code">find_callback</span> sono di semplice realizzazione: si può pensare ad esempio di utilizzare una <span class="code">std::map</span> per mantenere la tabella delle associazioni <span class="code">env</span>/<span class="code">WrappedCallback</span>, avendo cura di rimuovere le associazioni non più necessarie.</p>
<p>Il diagramma delle classi si è arricchito di due nuove classi:</p>
<a href="img/bluetooth-cpp-android/invoke-callback-class-diagram.png">
<img src="img/bluetooth-cpp-android/invoke-callback-class-diagram.png" width="600"/>
</a>
<p class="illustration">Class diagram con il supporto alle callback (click sull'immagine per ingrandirla).</p>
<p>Il codice sottostante esemplifica l'uso di un'API con callback:</p>
<pre class="code">
  ...
  BluetoothConnection connection = new BluetoothConnection(...);
  ...

  // initialization
  NativeAPI aNativeAPI = new NativeAPI();
  aNativeAPI.initialize(connection);
  ...

  // using the native API
  Callback callback = new Callback(...);
  String result = aNativeAPI.method(anIntValue, callback);
  ...

  // finalization
  aNativeAPI.finalize();
  ...
</pre>
<p>La sequenza delle chiamate si complica leggermente, nel caso di utilizzo di callback:</p>
<a href="img/bluetooth-cpp-android/invoke-callback-sequence-diagram.png">
<img src="img/bluetooth-cpp-android/invoke-callback-sequence-diagram.png" width="800"/>
</a>
<p class="illustration">Sequence diagram di una chiamata con callback (click sull'immagine per ingrandirla).</p>
<p>Prima di effettuare la chiamata nativa, l'applicativo Java istanzia l'oggetto <span class="code">Callback</span> (messaggio <span class="message">[2]</span>); prosegue quindi all'attivazione del metodo <span class="code">method</span> della classe <span class="code">NativeAPI</span> (<span class="message">[3]</span>), cui passa un riferimento all'oggetto callback appena creato. La chiamata viene inoltrata alla libreria di wrapping, che riceve il riferimento alla callback Java e lo deposita all'interno di un oggetto <span class="code">WrappedCallback</span> (<span class="message">[5]</span>) che viene successivamente inserito in un apposito registro (<span class="message">[6]</span>).</p>
<p>A questo punto viene invocato il metodo nativo (<span class="message">[7]</span>), cui viene passata una callback ausiliaria &ndash; <span class="code">wrapper_callback</span> &ndash; propria della libreria di wrapping. Si può presupporre che il codice nativo effettuerà un certo numero di comunicazioni con lo strumento remoto (<span class="message">[9]</span>), e di tanto in tanto chiamerà la callback locale (<span class="message">[12]</span>). Per tutta risposta, questa recupererà l'oggetto <span class="code">WrappedCallback</span> associato al contesto d'esecuzione corrente (<span class="message">[13]</span>), e lo attiverà con i valori ricevuti dalla libreria nativa (<span class="message">[14]</span>). I medesimi valori saranno quindi inoltrati alla callback Java (<span class="message">[15]</span>), ed il valore di ritorno ottenuto sarà ricondotto alla liberia nativa seguendo il percorso inverso (messaggi <span class="message">[16]</span>, <span class="message">[17]</span> e <span class="message">[18]</span>).</p>
<p>Al termine dell'esecuzione del metodo nativo (<span class="message">[19]</span>), la libreria di wrapping avrà cura, prima di uscire, di distruggere l'oggetto <span class="code">WrappedCallback</span> divenuto oramai inutile (messaggi <span class="message">[20]</span> e <span class="message">[21]</span>).</p>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


<!--  bluetooth-android.txt



using namespace mm;
using namespace comm;

JavaConnection::JavaConnection(JNIEnv* env, jobject connection)
 : env_(env)
 , connection_(nullptr)
 , open_(nullptr)
 , close_(nullptr)
 , send_(nullptr)
 , receive_(nullptr)
 , isOpened_(false) {
    // prevent `connection` object reallocation
    connection_ = env_->NewGlobalRef(connection);
    jclass instance = env_->GetObjectClass(connection_);
    open_ = bind(instance, "open", "()Z");
    close_ = bind(instance, "close", "()Z");
    send_ = bind(instance, "send", "([B)I");
    receive_ = bind(instance, "receive", "(I)[B");
    open();
}

JavaConnection::~JavaConnection() {
    if (isOpened_)
        close();
    // release the `connection` object to the java's GC
    env_->DeleteGlobalRef(connection_);
}

void JavaConnection::reset() {
    if (isOpened_) {
        close();
        open();
    }
}

int JavaConnection::send(const char* data, int count) {
    jbyteArray buffer = env_->NewByteArray(count);
    auto local = std::vector<jbyte>(count);
    for (int i = 0; i < count; ++i)
        local[i] = data[i];
    env_->SetByteArrayRegion(buffer, 0, count, local.data());
    jint sent = env_->CallIntMethod(connection_, send_, buffer);
    // release java objects as soon as possible
    env_->DeleteLocalRef(buffer);
    return static_cast<int>(sent);
}

int JavaConnection::receive(char* data, int expected) {
    jbyteArray buffer =
        static_cast<jbyteArray>(
            env_->CallObjectMethod(connection_, receive_, expected));
    jsize length = env_->GetArrayLength(buffer);
    void* local = env_->GetPrimitiveArrayCritical(buffer, 0);
    memcpy(data, local, length);
    env_->ReleasePrimitiveArrayCritical(buffer, local, 0);
    // release java objects as soon as possible
    env_->DeleteLocalRef(buffer);
    return static_cast<int>(length);
}

void JavaConnection::open() {
    if (isOpened_)
        return;
    isOpened_ = env_->CallBooleanMethod(connection_, open_);
    if (!isOpened_)
        MM_THROW(comm::Exception, "\"open\" returned `false`");
}

void JavaConnection::close() {
    if (!isOpened_)
        return;
    if (!env_->CallBooleanMethod(connection_, close_))
        MM_THROW(comm::Exception, "\"close\" returned `false`");
    isOpened_ = false;
}

jmethodID JavaConnection::bind(
    jclass instance, const char* name, const char* signature) {
    jmethodID id = env_->GetMethodID(instance, name, signature);
    if (id == NULL)
        MM_THROW(comm::Exception, "\"{}\" method not found", name);
    return id;
}


quando da Java si chiama f(), l'implementazione lavora in C++ fino a quando arriva
il momento di effettuare una trasmissione o una chiamata a callback. nel primo caso
si fa una chiamata all'oggetto JavaConnection che gira la chiamata all'oggetto Java,
nel secondo caso...


-->

<h2>Considerazioni sparse</h2>
<p class="todo">DEPLOY
dove va messa la libreria nativa?
dove va il codice c++ della libreria wrapper?
che file di progetto vanno modificati?

</p>
<p class="todo">"LOCK" DELL'OGGETTO JAVA DELLA CONNESSIONE CONTRO IL GC

1) lock dell'oggetto Java in memoria (se lo il GC lo sposta tra una chiamata e l'altra)
</p>
<pre>
JavaConnection::JavaConnection(JNIEnv* env, jobject connection)
 : env_(env)
 , connection_(nullptr)
 , open_(nullptr)
 , close_(nullptr)
 , send_(nullptr)
 , receive_(nullptr)
 , isOpened_(false) {
    // prevent `connection` object reallocation
    connection_ = env_-&gt;NewGlobalRef(connection);
    // bind dei metodi...
}

JavaConnection::~JavaConnection() {
    // cleanup...

    // release the `connection` object to the java&apos;s GC
    env_-&gt;DeleteGlobalRef(connection_);
}
</pre>
<p class="todo">"RELASE" IMMEDIATO DEI BUFFER DI MARSHALLING

2) release degli oggetti allocati appena possibile, se no si fa presto a raggiungere il limite massimo (256?!)
</p>
<pre>
int JavaConnection::send(const char* data, int count) {
    jbyteArray buffer = env_-&gt;NewByteArray(count);
    auto local = std::vector&lt;jbyte&gt;(count);
    for (int i = 0; i &lt; count; ++i)
        local[i] = data[i];
    env_-&gt;SetByteArrayRegion(buffer, 0, count, local.data());
    jint sent = env_-&gt;CallIntMethod(connection_, send_, buffer);
    // release java objects as soon as possible
    env_-&gt;DeleteLocalRef(buffer);
    return static_cast&lt;int&gt;(sent);
}
</pre>
<p class="todo">DIRE CHE L'EMULATORE DI ANDROID STUDIO NON SUPPORTA BLUETOOTH</p>
<p class="todo">CITARE I VARI CASINI DELL'NDK ORIGINALE E DEL PERCHE' SI E' OPTATO PER CRYSTAX</p>
<p class="todo">CITARE IL DISCORSO DEL CASINO DEL BUILD + DEPLOY DEGLI ARTEFATTI, DI COME LA LIBRERIA WRAPPER VIENE COMPILATA DA A. STUDIO VIA Android.makefile</p>

<p class="modification-notice">Pagina modificata il 28/04/2017</p>
</body>
</html>
